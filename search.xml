<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux中syncookies参数</title>
      <link href="/2019/04/04/Linux%E4%B8%ADSYN%20Cookie%E5%8F%82%E6%95%B0/"/>
      <url>/2019/04/04/Linux%E4%B8%ADSYN%20Cookie%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="SYN-Flood"><a href="#SYN-Flood" class="headerlink" title="SYN Flood"></a>SYN Flood</h3><p>SYN Flood攻击是一种典型的拒绝服务(Denial of Service)攻击。所谓的拒绝服务攻击就是通过进行攻击，使受害主机或网络不能提供良好的服务，从而间接达到攻击的目的。</p><p>SYN Flood攻击利用的是IPv4中TCP协议的三次握手(Three-Way Handshake)过程进行的攻击。下面是三次握手的过程：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJely1g1rihpjkkyj30ag08y74d.jpg" alt></p><p>TCP服务器收到TCP SYN request包时，在发送TCP SYN + ACK包回客户机（第三次握手）前，TCP服务器要先分配好一个<strong>数据区</strong>，专门服务于这个即将形成的TCP连接。一般把收到SYN包而还未收到ACK包时的连接状态称为半打开连接(Half-open Connection)。</p><p>在最常见的SYN Flood攻击中，攻击者在短时间内发送大量的TCP SYN包给受害者。受害者(服务器)为每个TCP SYN包分配一个特定的数据区，只要这些SYN包具有不同的源地址(攻击者很容易伪造)。这将给TCP服务器造成很大的系统负担，最终导致系统不能正常工作。</p><p>SYN Flood是一种非常危险而常见的Dos攻击方式。到目前为止，能够有效防范SYN Flood攻击的手段并不多，SYN Cookie就是其中最著名的一种。</p><a id="more"></a><h3 id="SYN-Cookie"><a href="#SYN-Cookie" class="headerlink" title="SYN Cookie"></a>SYN Cookie</h3><p>SYN Cookie原理由D.J. Bernstain和Eric Schenk提出。SYN Cookie是对TCP服务器端的三次握手做一些修改，专门用来防范SYN Flood攻击的一种手段。</p><p>它的原理是，在TCP服务器接收到TCP SYN包并返回TCP SYN + ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。这个cookie作为将要返回的SYN ACK包的初始序列号。当客户端返回一个ACK包时，根据包头信息计算cookie，与返回的确认序列号(初始序列号 + 1)进行对比，如果相同，则是一个正常连接，然后，分配资源，建立连接。</p><p>实现的关键在于cookie的计算，cookie的计算应该包含本次连接的状态信息，使攻击者不能伪造。具体实现方法wiki ：<a href="https://zh.wikipedia.org/wiki/SYN_cookie" target="_blank" rel="noopener">SYN cookie</a></p><p>在Linux中使用时，设置内核参数使用即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"net.ipv4.tcp_syncookies = 1"</span>&gt;&gt;/etc/sysctl.conf   <span class="comment"># 1表示开启SYN Cookies,默认为0，表示关闭；</span></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zh.wikipedia.org/wiki/SYN_cookie" target="_blank" rel="noopener">SYN cookie</a></p><p><a href="https://blog.csdn.net/zhangskd/article/details/16986931" target="_blank" rel="noopener">SYN cookie 原理</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile中ENTRYPOINT与CMD的区别</title>
      <link href="/2019/04/02/Dockerfile%E4%B8%ADENTRYPOINT%E4%B8%8ECMD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/04/02/Dockerfile%E4%B8%ADENTRYPOINT%E4%B8%8ECMD%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="Dockerfile-中ENTRYPOINT与CMD的区别"><a href="#Dockerfile-中ENTRYPOINT与CMD的区别" class="headerlink" title="Dockerfile 中ENTRYPOINT与CMD的区别"></a>Dockerfile 中ENTRYPOINT与CMD的区别</h3><p>可以从以下三方面看出：</p><h4 id="Shell-vs-Exec"><a href="#Shell-vs-Exec" class="headerlink" title="Shell vs. Exec"></a>Shell vs. Exec</h4><p>ENTRYPOINT和CMD指令支持2种不同的写法: shell表示法和exec表示法. </p><ul><li>exec格式 <code>[“executable”, “param1”, “param2”]</code>(推荐)</li><li>shell格式 <code>command param1 param2</code> </li></ul><p>CMD 和 ENTRYPOINT两种配置格式的区别是:</p><ul><li><code>exec格式</code>使用这种模式时，可以不需要 shell进程，让Docker应用的可执行程成为容器的PID1进程，可以接收Unix信号，比如执行docker stop时能够接收到SIGTERM。</li><li><code>shell格式</code>会始终调用一个shell进程，成为<code>/bin/sh -c</code>的子命令，可执行程序不能响应Unix信号。</li></ul><a id="more"></a><h4 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h4><p>在docker镜像运行时, 用户也可以在命令指定具体命令, 覆盖在Dockerfile里的命令</p><p>比如, 我们写了一个这样的Dockerfile:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox:latest </span><br><span class="line">CMD ping localhost</span><br></pre></td></tr></table></figure></p><p>如果根据这个Dockerfile构建一个新image, 名字叫demo<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker built -t demo .</span><br><span class="line">[truncated]</span><br><span class="line"></span><br><span class="line">$ docker run -t demo</span><br><span class="line">PING localhost (127.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.051 ms</span><br><span class="line">64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.038 ms</span><br><span class="line">^C</span><br><span class="line">--- localhost ping statistics ---</span><br><span class="line">2 packets transmitted, 2 received, 0% packet loss, time 999ms</span><br><span class="line">rtt min/avg/max/mdev = 0.026/0.032/0.039/0.008 ms</span><br></pre></td></tr></table></figure></p><p>可以看出ping命令在docker启动后自己执行, 但是我们可以在命令行启动docker镜像时, 执行其他命令行参数, 覆盖了默认的CMD<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run demo hostname</span><br><span class="line">fa5066056477</span><br></pre></td></tr></table></figure></p><p>docker启动后, 并没有执行ping命令, 而是运行了hostname命令</p><p>当在Dockerfile中使用ENTRYPOINT时,<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox:latest </span><br><span class="line">ENTRYPOINT ping localhost</span><br></pre></td></tr></table></figure></p><p>在替换默认的命令，则需要在执行docker run的时候指定 <code>--entrypoint</code>参数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --entrypoint hostname demo</span><br><span class="line">fa5066056477</span><br></pre></td></tr></table></figure></p><p>因为CMD命令很容易被docker run命令的方式覆盖, 所以, 如果你希望你的docker镜像的功能足够灵活, 建议在Dockerfile里调用CMD命令。</p><h4 id="ENTRYPOINT-和-CMD组合使用"><a href="#ENTRYPOINT-和-CMD组合使用" class="headerlink" title="ENTRYPOINT 和 CMD组合使用"></a>ENTRYPOINT 和 CMD组合使用</h4><p>之前只讨论了用ENTRYPOINT或者CMD之一指定image的默认运行程序, 但是在某种情况下, ENTRYPOINT和CMD还能组合使用，当ENTRYPOINT和CND同时使用时，CMD作为ENTRYPOINT的参数。</p><p>看下面的一个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM busybox:latest </span><br><span class="line">ENTRYPOINT [<span class="string">"/bin/ping"</span>,<span class="string">"-c"</span>,<span class="string">"3"</span>]</span><br><span class="line">CMD [<span class="string">"localhost"</span>]</span><br></pre></td></tr></table></figure></p><p>运行它，<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t ping .</span><br><span class="line">[truncated]</span><br><span class="line"></span><br><span class="line">$ docker run ping</span><br><span class="line">PING localhost (127.0.0.1) 56(84) bytes of data.</span><br><span class="line">64 bytes from localhost (127.0.0.1): icmp_seq=1 ttl=64 time=0.025 ms</span><br><span class="line">64 bytes from localhost (127.0.0.1): icmp_seq=2 ttl=64 time=0.038 ms</span><br><span class="line">64 bytes from localhost (127.0.0.1): icmp_seq=3 ttl=64 time=0.051 ms</span><br></pre></td></tr></table></figure></p><p>容器在启动后，localhost作为ping命令的参数</p><h4 id="CMD和ENTRYPOINT的使用总结如下："><a href="#CMD和ENTRYPOINT的使用总结如下：" class="headerlink" title="CMD和ENTRYPOINT的使用总结如下："></a><code>CMD</code>和<code>ENTRYPOINT</code>的使用总结如下：</h4><ul><li>在Dockerfile中，应该至少指定一个CMD和ENTRYPOINT</li><li>CMD 可以被 docker run直接传入的参数覆盖，而ENTRYPOINT则需要加上<code>--enterpoint</code>才能生效；</li><li>将Docker当作可执行程序时，应该使用ENTRYPOINT进行配置；</li><li>CMD和ENTRYPOINT同时使用时，用作 ENTRYPOINT 默认参数，单独使用时用作Docker的默认命令；多条CMD同时使用时，只有最后一个CDM生效；</li></ul><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://zhuanlan.zhihu.com/p/30555962" target="_blank" rel="noopener">Dockerfile: ENTRYPOINT和CMD的区别</a></p><p><a href="https://www.google.com/search?q=docker%E4%B8%ADentpoint%E5%92%8Ccmd%E7%9A%84%E5%8C%BA%E5%88%AB&amp;oq=docker%E4%B8%ADentpoint%E5%92%8Ccmd%E7%9A%84%E5%8C%BA%E5%88%AB&amp;aqs=chrome..69i57.17343j0j4&amp;sourceid=chrome&amp;ie=UTF-8" target="_blank" rel="noopener">google</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript经典的例子</title>
      <link href="/2019/03/26/JavaScript%E5%AE%9E%E4%BE%8B/"/>
      <url>/2019/03/26/JavaScript%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<p>随手记录一些JavaScript经典实例，方便以后复习。。。<br><a id="more"></a></p><h3 id="1-弹性盒模型"><a href="#1-弹性盒模型" class="headerlink" title="1.弹性盒模型"></a>1.弹性盒模型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;弹性盒模型&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">body,ul&#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">li&#123;</span><br><span class="line">list-style: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu_con&#123;</span><br><span class="line">width: 960px;</span><br><span class="line">height: 80px;</span><br><span class="line">margin: 50px auto 0;</span><br><span class="line">display: flex;</span><br><span class="line">background-color: #ddd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.logo&#123;</span><br><span class="line">width: 150px;</span><br><span class="line">height: 80px;</span><br><span class="line">background-color: green;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu&#123;</span><br><span class="line">flex-grow: 1;</span><br><span class="line">align-items: center;</span><br><span class="line">display: flex;</span><br><span class="line">overflow: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu li&#123;</span><br><span class="line">flex-grow: 1;</span><br><span class="line">text-align:center;</span><br><span class="line">border-right:1px solid #333;</span><br><span class="line">margin-right:-1px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu li a&#123;</span><br><span class="line">text-decoration: none;</span><br><span class="line">color: #666;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media(max-width: 960px) &#123;</span><br><span class="line">.menu_con&#123;</span><br><span class="line">width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;menu_con&quot;&gt;</span><br><span class="line">&lt;div class=&quot;logo&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;ul class=&quot;menu&quot;&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;首页&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;公司简介&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;公司新闻&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;行业动态&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;联系我们&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="2-响应式布局"><a href="#2-响应式布局" class="headerlink" title="2.响应式布局"></a>2.响应式布局</h3><p>应用于手机端的响应式布局<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br><span class="line">&lt;title&gt;响应式布局&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">ul,li&#123;</span><br><span class="line">margin:0;</span><br><span class="line">padding: 0;</span><br><span class="line">list-style: none;</span><br><span class="line">&#125;</span><br><span class="line">.con&#123;</span><br><span class="line">border:1px solid #ddd;</span><br><span class="line">&#125;</span><br><span class="line">.con li&#123;</span><br><span class="line">/*display: inline-block;*/</span><br><span class="line">float: left;</span><br><span class="line">height: 50px;</span><br><span class="line">width: 23%;</span><br><span class="line">background-color: pink;</span><br><span class="line">margin:0 1%;</span><br><span class="line">text-align: center;</span><br><span class="line">line-height: 50px;</span><br><span class="line">font-size: 20px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@media (max-width:800px)&#123;</span><br><span class="line"></span><br><span class="line">.con li&#123;</span><br><span class="line">width:46%;</span><br><span class="line">margin:30px 2%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@media (max-width:500px)&#123;</span><br><span class="line"></span><br><span class="line">.con li&#123;</span><br><span class="line">width:90%;</span><br><span class="line">margin:30px 5%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul class=&quot;con&quot;&gt;</span><br><span class="line">&lt;li&gt;1&lt;/li&gt;</span><br><span class="line">&lt;li&gt;2&lt;/li&gt;</span><br><span class="line">&lt;li&gt;3&lt;/li&gt;</span><br><span class="line">&lt;li&gt;4&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3-javascript数组去重"><a href="#3-javascript数组去重" class="headerlink" title="3.javascript数组去重"></a>3.javascript数组去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var aList = [1,2,3,4,4,3,2,1,2,3,4,5,6,5,5,3,3,4,2,1];</span><br><span class="line"></span><br><span class="line">var aList2 = [];</span><br><span class="line"></span><br><span class="line">for(var i=0;i&lt;aList.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    if(aList.indexOf(aList[i])==i)</span><br><span class="line">    &#123;</span><br><span class="line">        aList2.push(aList[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(aList2);</span><br></pre></td></tr></table></figure><h3 id="4-选项卡"><a href="#4-选项卡" class="headerlink" title="4.选项卡"></a>4.选项卡</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;jQuery选项卡&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"></span><br><span class="line">.con&#123;</span><br><span class="line">width: 500px; /*块元素不设置高宽，默认为父子元素的宽度，高度为内容宽度*/</span><br><span class="line">margin: 50px auto 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btns&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 50px;</span><br><span class="line">&#125;</span><br><span class="line">.btns &#123;</span><br><span class="line">padding: 0;</span><br><span class="line">margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">.btns li&#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 50px;</span><br><span class="line">background-color: #ddd;</span><br><span class="line"></span><br><span class="line">padding: 0;</span><br><span class="line">margin: 0;</span><br><span class="line"></span><br><span class="line">font: 14px/50px &apos;Micorsoft Yahei&apos;;</span><br><span class="line">text-align: center;</span><br><span class="line">cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btns li.cur&#123;  /*让当前类选择器的权重增大*/</span><br><span class="line">background-color: RGB(160, 198, 232);</span><br><span class="line">list-style: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.contents div&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 300px;</span><br><span class="line">background-color: RGB(160, 198, 232);</span><br><span class="line">display: none;</span><br><span class="line">font: 20px/300px &apos;Micorsoft Yahei&apos;;</span><br><span class="line">text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.contents .active&#123;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">window.onload = function()&#123;</span><br><span class="line"></span><br><span class="line">var aBtn = document.getElementById(&apos;btns&apos;).getElementsByTagName(&apos;input&apos;);</span><br><span class="line">var aCon = document.getElementById(&apos;contents&apos;).getElementsByTagName(&apos;div&apos;);</span><br><span class="line"></span><br><span class="line">for(var i=0 ; i &lt; aBtn.length;i++)&#123;</span><br><span class="line">(function(i)&#123;                          //闭包保存i的值</span><br><span class="line">aBtn[i].onclick = function()&#123;</span><br><span class="line">for(var j = 0; j &lt; aCon.length;j++)&#123;</span><br><span class="line">aBtn[j].className =&apos;&apos;;</span><br><span class="line">aCon[j].className =&apos;&apos;;</span><br><span class="line">&#125;</span><br><span class="line">aBtn[i].className = &apos;cur&apos;;</span><br><span class="line">aCon[i].className = &apos;active&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;con&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul class=&quot;btns&quot; id=&quot;btns&quot;&gt;</span><br><span class="line">&lt;li&gt;选项一&lt;/li class=&quot;cur&quot;&gt;</span><br><span class="line">&lt;li&gt;选项二&lt;/li&gt;</span><br><span class="line">&lt;li&gt;选项三&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;contents&quot; id=&quot;contents&quot;&gt;</span><br><span class="line">&lt;div class=&quot;active&quot;&gt;内容一&lt;/div&gt;</span><br><span class="line">&lt;div&gt;内容二&lt;/div&gt;</span><br><span class="line">&lt;div&gt;内容三&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><strong>jQuery实现</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;jQuery选项卡&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&apos;js/jquery-1.12.4.min.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"></span><br><span class="line">.con&#123;</span><br><span class="line">width: 500px; /*块元素不设置高宽，默认为父子元素的宽度，高度为内容宽度*/</span><br><span class="line">margin: 50px auto 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btns&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 50px;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btns &#123;</span><br><span class="line">padding: 0;</span><br><span class="line">margin: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btns li&#123;</span><br><span class="line">display: inline-block;</span><br><span class="line">width: 100px;</span><br><span class="line">height: 50px;</span><br><span class="line">background-color: #ddd;</span><br><span class="line"></span><br><span class="line">list-style: none;</span><br><span class="line">font: 14px/50px &apos;Micorsoft Yahei&apos;;</span><br><span class="line">text-align: center;</span><br><span class="line">cursor: pointer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.btns li.cur&#123;  /*让当前类选择器的权重增大*/</span><br><span class="line">background-color: RGB(160, 198, 232);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.contents div&#123;</span><br><span class="line">width: 500px;</span><br><span class="line">height: 300px;</span><br><span class="line">background-color: RGB(160, 198, 232);</span><br><span class="line">display: none;</span><br><span class="line">font: 20px/300px &apos;Micorsoft Yahei&apos;;</span><br><span class="line">text-align: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.contents .active&#123;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">$(function()&#123;</span><br><span class="line">$(&apos;#btns li&apos;).click(function()&#123;</span><br><span class="line">//this是原生对象</span><br><span class="line">$(this).addClass(&apos;cur&apos;).siblings().removeClass(&apos;cur&apos;);</span><br><span class="line"></span><br><span class="line">//$(this).index()获取当前所在层级的属性值</span><br><span class="line">$(&apos;#contents div&apos;).eq($(this).index()).addClass(&apos;active&apos;).siblings().removeClass(&apos;active&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div class=&quot;con&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;ul class=&quot;btns&quot; id=&quot;btns&quot;&gt;</span><br><span class="line">&lt;li&gt;选项一&lt;/li class=&quot;cur&quot;&gt;</span><br><span class="line">&lt;li&gt;选项二&lt;/li&gt;</span><br><span class="line">&lt;li&gt;选项三&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;contents&quot; id=&quot;contents&quot;&gt;</span><br><span class="line">&lt;div class=&quot;active&quot;&gt;内容一&lt;/div&gt;</span><br><span class="line">&lt;div&gt;内容二&lt;/div&gt;</span><br><span class="line">&lt;div&gt;内容三&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://oq6z4u4s9.bkt.clouddn.com/1502415598958.jpg" alt="enter description here"></p><h4 id="5-登录弹窗"><a href="#5-登录弹窗" class="headerlink" title="5.登录弹窗"></a>5.登录弹窗</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;用户登录&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">window.onload = function()&#123;</span><br><span class="line"></span><br><span class="line">var oPop = document.getElementById(&apos;pop&apos;);</span><br><span class="line">var oShut = document.getElementById(&apos;shutoff&apos;);</span><br><span class="line"></span><br><span class="line"> setTimeout(function()&#123;</span><br><span class="line"> oPop.style.display = &apos;block&apos;;</span><br><span class="line"></span><br><span class="line"> &#125;,3000);</span><br><span class="line"></span><br><span class="line">oShut.onclick = function()&#123;</span><br><span class="line">oPop.style.display = &apos;none&apos;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">body&#123;</span><br><span class="line">margin: 0;</span><br><span class="line">&#125;</span><br><span class="line">.pop_con&#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line">.pop&#123;</span><br><span class="line">width: 400px;</span><br><span class="line">height: 300px;</span><br><span class="line">background-color: #fff;</span><br><span class="line">border:1px solid #eee;</span><br><span class="line">position: fixed;</span><br><span class="line"></span><br><span class="line">left: 50%;</span><br><span class="line">top: 50%;</span><br><span class="line">margin-left: -200px;</span><br><span class="line">margin-top: -150px;</span><br><span class="line">z-index: 9999;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.mask&#123;</span><br><span class="line">position:fixed;</span><br><span class="line">width:100%;</span><br><span class="line">height:100%;</span><br><span class="line">background-color:rgb(230, 245, 255);</span><br><span class="line">left:0;</span><br><span class="line">top:0;</span><br><span class="line">opacity:0.7;</span><br><span class="line">filter:alpha(opacity=30);</span><br><span class="line">z-index:9990;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;首页&lt;/h1&gt;</span><br><span class="line">网页正文。。。</span><br><span class="line"></span><br><span class="line">&lt;div class=&quot;pop_con&quot; id=&quot;pop&quot;&gt;</span><br><span class="line">&lt;div class=&quot;pop&quot;&gt;</span><br><span class="line">&lt;h2&gt;提示信息！&lt;/h2&gt;</span><br><span class="line">&lt;a href=&quot;&quot; id=&quot;shutoff&quot;&gt;关闭&lt;/a&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;div class=&quot;mask&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="6-JavaScript继承"><a href="#6-JavaScript继承" class="headerlink" title="6.JavaScript继承"></a>6.JavaScript继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;javascript继承&lt;/title&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//父类</span><br><span class="line">function Fclass(name,age)&#123;</span><br><span class="line">this.name = name;</span><br><span class="line">this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fclass.prototype.showname = function() &#123;</span><br><span class="line">alert(this.name)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Fclass.prototype.showage = function() &#123;</span><br><span class="line">alert(this.age)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//子类</span><br><span class="line">function Sclass(name,age,job)&#123;</span><br><span class="line">Fclass.call(this,name,age); //子类通过父类构造函数中的call或者apply的方法继承父类的属性</span><br><span class="line">this.job = job;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sclass.prototype = new Fclass(); //将父类的一个实例赋值给子类的原型属性</span><br><span class="line"></span><br><span class="line">Sclass.prototype.showjob = function()&#123;</span><br><span class="line"></span><br><span class="line">alert(this.job);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Tom = new Sclass(&apos;Tom&apos;,18,&apos;engineer&apos;);</span><br><span class="line"></span><br><span class="line">Tom.showage();</span><br><span class="line">Tom.showname();</span><br><span class="line">Tom.showjob();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h4 id="7-层级菜单"><a href="#7-层级菜单" class="headerlink" title="7.层级菜单"></a>7.层级菜单</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;层级菜单&lt;/title&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line"></span><br><span class="line">body&#123;</span><br><span class="line">font-family: &apos;Micorsoft Yahei&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ul&#123;</span><br><span class="line">margin: 0;</span><br><span class="line">padding: 0;</span><br><span class="line">list-style: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu&#123;</span><br><span class="line">width: 200px;</span><br><span class="line">margin: 50px auto 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu .level1 ,.menu li ul a&#123;</span><br><span class="line">display: block;</span><br><span class="line">height: 30px;</span><br><span class="line">width: 200px;</span><br><span class="line">line-height: 30px;</span><br><span class="line">text-decoration: none;</span><br><span class="line">background-color: #3366cc;</span><br><span class="line">color: #fff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu .level1&#123;</span><br><span class="line">border-bottom: 1px solid rgb(175, 198, 246);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu li ul&#123;</span><br><span class="line">display: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu li ul a&#123;</span><br><span class="line">font-size:14px;</span><br><span class="line">text-indent:20px;</span><br><span class="line">background-color:#7aa1ef;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu li ul li&#123;</span><br><span class="line">border-bottom:1px solid #afc6f6;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.menu li ul.current&#123;</span><br><span class="line">display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.menu li ul li a:hover&#123;</span><br><span class="line">background-color: #f6b544;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot; src=&apos;js/jquery-1.12.4.min.js&apos;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">$(function()&#123;</span><br><span class="line">/*</span><br><span class="line">$(&apos;.level1&apos;).click(function() &#123;</span><br><span class="line">$(this).next().toggleClass(&apos;current&apos;);</span><br><span class="line">&#125;);*/</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">$(&apos;.level1&apos;).click(function() &#123;</span><br><span class="line">$(this).next().slideToggle();</span><br><span class="line">&#125;);*/</span><br><span class="line"></span><br><span class="line">$(&apos;.level1&apos;).click(function()&#123;</span><br><span class="line"></span><br><span class="line">$(this).next().slideDown().parent().siblings().children(&apos;ul&apos;).slideUp();</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;ul class=&quot;menu&quot;&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a href=&quot;#&quot; class=&quot;level1&quot;&gt;水果&lt;/a&gt;</span><br><span class="line">&lt;ul class=&quot;current&quot;&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;苹果&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;梨子&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;葡萄&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;火龙果&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a href=&quot;#&quot; class=&quot;level1&quot;&gt;海鲜&lt;/a&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;蛏子&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;扇贝&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;龙虾&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;象拔蚌&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a href=&quot;#&quot; class=&quot;level1&quot;&gt;肉类&lt;/a&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;内蒙古羊肉&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;进口牛肉&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;野猪肉&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a href=&quot;#&quot; class=&quot;level1&quot;&gt;蔬菜&lt;/a&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;娃娃菜&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;西红柿&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;西芹&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;胡萝卜&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">&lt;a href=&quot;#&quot; class=&quot;level1&quot;&gt;速冻&lt;/a&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;冰淇淋&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;湾仔码头&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;海参&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;a href=&quot;#&quot;&gt;牛肉丸&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p><img src="http://oq6z4u4s9.bkt.clouddn.com/1502466432709.jpg" alt="enter description here"></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell编程总结</title>
      <link href="/2018/06/23/shell_summary/"/>
      <url>/2018/06/23/shell_summary/</url>
      
        <content type="html"><![CDATA[<h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><p>本文主要对一些shell常用知识总结</p><h3 id="分隔符使用"><a href="#分隔符使用" class="headerlink" title="分隔符使用"></a>分隔符使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if [ -f fliename ];then</span><br><span class="line">...</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 等同于以下</span><br><span class="line">if [ -f fliname ]    #不同的语法命令之间要用分号或是换行隔开，可以用换行符替代分割符</span><br><span class="line">then</span><br><span class="line">...</span><br><span class="line">fi  # shell语句用fi闭合</span><br></pre></td></tr></table></figure><a id="more"></a><p>由此可见分号是用来隔断每个语法关键字或命令的。对于字符的比较及其他shell语法关键字之间分号的使用方式相同。<br>需要知道的是在不同的语法命令之间要用分号隔开或是换行方能执行，否则将会在调用脚本的时候报错。</p><h3 id="数组应用"><a href="#数组应用" class="headerlink" title="数组应用"></a>数组应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@cloudhost ~]# name=(hello error)</span><br><span class="line">[root@cloudhost ~]# for i in $&#123;name[@]&#125;;do echo $i; done;</span><br></pre></td></tr></table></figure><p>shell中用arrary=(arr1 arr2 arr3 ……) 的方式声明数组<br>访问数组时使用${arrary[@]}访问整个数组 ，@表示数组索引表，<br>使用${p[index]}访问数组中的某个特定的值。</p><h3 id="if-then的基本特性和高级用法"><a href="#if-then的基本特性和高级用法" class="headerlink" title="if-then的基本特性和高级用法"></a>if-then的基本特性和高级用法</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if [ -x flie ];then  # 测试用户是否可执行文件,以下为其他一些测试语句</span><br><span class="line">  ...</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>条件测试</p><blockquote><p><code>-d</code> 测试是否为目录，是则为真（Directory）<br><code>-e</code> 测试目录或文件是否存在，存在则为真（Exist）<br><code>-f</code> 测试是否为文件，是则为真（File）<br><code>-r</code> 测试当前用户是否有权限读取，是则为真（Read）<br><code>-w</code> 测试当前用户是否有权限写入，是这为真（Write）<br><code>-x</code> 测试当前用户是否可执行该文件，可执行则为真（Excute）<br><code>-L</code> 测试是否为符号链接文件，是则为真（Link）<br><code>-nt</code> file1 -nt file2 如果 file1 比 file2 新（修改时间），则为真<br><code>-ot</code> file1 -ot file2 如果 file1 比 file2 旧（修改时间），则为真</p></blockquote><p>字符串比较</p><blockquote><p><code>=</code> 字符串内容相同则为真，就是说包含的文本一摸一样。<br><code>!=</code> 字符串内容不同，则为真（!号表示相反的意思）<br><code>-z</code> 字符串内容为空（长度为零）则为真<br><code>-n</code> 字符串内容非空（长度非零）则为真<br><code>&lt;</code> string1 &lt; string2 如果string1在本地的字典序列中排在string2之前，则为真<br><code>&gt;</code> string2 如果string1在本地的字典序列中排在string2之后，则为真</p></blockquote><p>==注意：==</p><ul><li>字符串的 “等于” 比较，为了与POSIX一致，在<code>[]</code>中使用<code>=</code>，（尽管<code>==</code>也可以可以用的）</li><li><strong>注意在<code>=</code>前后各有一个空格，如果没有空格就是赋值的关系，不是比较的关系。</strong></li><li>字符串的<code>&gt; &lt;</code>比较运算符，一般放在<code>[[ ]]</code>之中，而不是test (“[]”)</li><li>字符串的<code>&gt; &lt;</code>比较的结果，与本地的locale有关，是按照其字典序列进行比较的</li></ul><p>数值比较</p><blockquote><p><code>-eq</code> 等于（equal）<br><code>-ne</code>：不等于（not equal）<br><code>-gt</code>：大于（Greater than）<br><code>-lt</code>：小于（lesser than）<br><code>-le</code>：小于等于（lesser or equal）<br><code>-ge</code>：大于等于（Greater or equal）</p></blockquote><p>逻辑测试</p><blockquote><p><code>-a</code> 或 <code>&amp;&amp;</code>  逻辑与，“而且”的意思，前后两个表达式都成立时整个测试结果才为真，否则为假<br><code>-o</code> 或 <code>||</code>  逻辑或，“或者”的意思，操作符两边至少一个为真时，结果为真，否为为假<br><code>!</code> 逻辑否，当制定条件不成立时，返回结果为真</p></blockquote><h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h4><p>由于单括方号不支持表达式,test只支持简单的算术操作，双括号解决了此类问题</p><ul><li><p>用于数学表达式的双括号<br> 格式<br> <code>(( expression1,expression2 ))</code><br> expression可以是任意的数学赋值或比较表达式,如下：</p><blockquote><p><code>val++</code>  后增<br> <code>val--</code>  后减<br> <code>++val</code>   先增<br> <code>--val</code>   先减<br> <code>!</code>     逻辑取反</p></blockquote><p> 示例</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (( val ** &gt; 90 ))  #用于测试</span><br><span class="line">$(( a&gt;1?8:9 ))  #三目运算</span><br><span class="line">$(( a=a+1 )) </span><br><span class="line">a=$(( a+1,b++,c++ ))</span><br></pre></td></tr></table></figure><p>  特点</p><ul><li>在双括号结构中，所有表达式可以像c语言一样，如：<code>a++</code>,<code>b--</code>等。</li><li>在双括号结构中，所有变量可以不加入：“$”符号前缀。</li><li>双括号可以进行逻辑运算，四则运</li><li>双括号结构 扩展了for，while,if条件测试运算</li><li>支持多个表达式运算，各个表达式之间用“，”分开</li></ul></li><li><p>用户高级字符串处理的双方括号</p><p>  格式</p><pre><code>`[[ expression ]]`双方括号里的expression使用了test中的标准字符串比较，但它提供了test没有提供的特性--`模式匹配`。</code></pre><p>  示例</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [[ $USER == r* ]] #是否是以r开头的行</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><blockquote><p><code>$#</code> 传给shell程序的位置参数个数；<br><code>$0</code> 脚本名称；<br><code>$?</code> 最后命令的完成码或在shell程序内所执行的shell程序；<br><code>$n</code> (n&gt;0)获取传递的第n个参数</p></blockquote><p>参考</p><p><a href="http://www.cnblogs.com/chengmo/archive/2010/10/19/1855577.html" target="_blank" rel="noopener">linux shell “(())” 双括号运算符使用</a> </p>]]></content>
      
      
      <categories>
          
          <category> Linux Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>./和. 执行脚本的执行方式解析</title>
      <link href="/2018/06/23/shell_run/"/>
      <url>/2018/06/23/shell_run/</url>
      
        <content type="html"><![CDATA[<p>我们经常使用多种方式运行脚本的方法，那他们的原理是什么呢？</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk4oz8fsj30p90de3zo.jpg" alt="enter description here"><br><a id="more"></a></p><p>先在/root写一个脚本：<br><code>vim hello.sh</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">cd /tmp</span><br><span class="line">echo"hello guys!"</span><br><span class="line">echo"welcome to Nova's blog"</span><br></pre></td></tr></table></figure><p>脚本可能执行出现的问题：</p><ul><li>是否加权限文件才可以执行？</li><li>执行成功目录是否改变？</li></ul><h3 id="bash-sh方法运行："><a href="#bash-sh方法运行：" class="headerlink" title="bash sh方法运行："></a>bash sh方法运行：</h3><blockquote><p>[root@localhost ~]# bash hello.sh<br>hello guys!<br>welcome to Nova’s blog</p><p>[root@localhost ~]# pwd<br>/root</p></blockquote><blockquote><p>[root@localhost ~]# sh hello.sh<br>hello guys!<br>welcome to Nova’s blog</p><p>[root@localhost ~]# pwd<br>/root</p></blockquote><p><strong>运行原理：当使用bash命令去执行文件时，shell会重新建立一个子shell执行脚本里面的语句，该子shell继承父shell的环境变量，但子shell新建的、改变的变量不会被带回父shell，除非使用export，所以目录没有改变。</strong></p><h3 id="source-方法执行"><a href="#source-方法执行" class="headerlink" title="source . 方法执行"></a>source . 方法执行</h3><p>source命令：<br>source命令也称为“点命令”，也就是一个点符号（.）,是bash的内部命令。</p><ul><li>功能：<br><strong>使Shell读入指定的Shell程序文件并依次执行文件中的所有语句。</strong><br>source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。</li><li>用法：<br>source filename 或 . filename<br>source命令(从 C Shell 而来)是bash shell的内置命令;点命令(.)，就是个点符号(从Bourne Shell而来)是source的另一名称。</li></ul><blockquote><p>[root@localhostz ~]# source hello.sh<br>hello guys!<br>welcome to Nova’s blog</p></blockquote><blockquote><p>[root@localhost tmp]# pwd<br>/tmp</p></blockquote><blockquote><p>[root@localhost ~]# . hello.sh<br>hello guys!<br>welcome to Nova’s blog</p></blockquote><blockquote><p>[root@localhost tmp]# pwd<br>/tmp</p></blockquote><p><strong>运行原理：在当前shell中，source读入指定的Shell程序文件并依次执行文件中的所有语句，并执行，因为脚本在当前shell中执行，所以目录改变。</strong></p><h3 id="绝对路径和相对路径执行"><a href="#绝对路径和相对路径执行" class="headerlink" title="绝对路径和相对路径执行"></a>绝对路径和相对路径执行</h3><blockquote><p>[root@localhost ~]# ./hello.sh<br>bash: ./hello.sh: Permission denied</p></blockquote><blockquote><p>[root@localhost ~]# /root/hello.sh<br>bash: /root/hello.sh: Permission denied</p></blockquote><blockquote><p>[root@localhost ~]# chmod +x hello.sh #给予文件执行权限<br>[root@localhost ~]# ./hello.sh<br>hello guys!<br>welcome to Nova’s blog</p><p>[root@localhost tmp]# pwd<br>/tmp</p></blockquote><p>在弄懂运行原理之前先看ls命令是怎么执行的：<br>其实ls 命令都是用文件的路径的命令运行，其路径用which查看如下：</p><blockquote><p>[root@localhost ~]# which ls<br>alias ls=’ls –color=auto’  #命令别名<br>/usr/bin/ls #文件路径</p></blockquote><p>也就是说当你在命令行键入ls是，shell会通过环境变量映射的路径目录下去找可执行的文件</p><p><strong>运行原理：当在命令行读入一行字符串时，shell会去系统的环境变量的目录下去查找相关问件或者通过路径查找并价判断它是否为可执行的文件，然后在打开一个子shell去运行文件（脚本或二进制文件ELF），所以目录没有改变。</strong></p><p>如果对shell所产生的子shell有疑问，尝试如下例子：</p><ol><li>新建一个test.sh脚本，内容为:A=1</li><li>然后使其可执行chmod +x test.sh</li><li>运行sh test.sh后，echo $A，显示为空，因为A=1并未传回给当前shell</li><li>运行./test.sh后，也是一样的效果</li><li>运行source test.sh 或者 . test.sh，然后echo $A，则会显示1，说明A=1的变量在当前shell中</li></ol><p>参考：<br> 1.<a href="http://www.51testing.com/html/38/225738-206878.html" target="_blank" rel="noopener">http://www.51testing.com/html/38/225738-206878.html</a><br> 2.<a href="http://4554480.blog.51cto.com/4544480/837006" target="_blank" rel="noopener">http://4554480.blog.51cto.com/4544480/837006</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文本处理三剑客之awk</title>
      <link href="/2018/04/30/Linux_awk/"/>
      <url>/2018/04/30/Linux_awk/</url>
      
        <content type="html"><![CDATA[<h2 id="awk简介"><a href="#awk简介" class="headerlink" title="awk简介"></a>awk简介</h2><p>awk是一种解释执行的编程语言，用来专门处理文本数据，其名称是由它们设计者的名字缩写而来 ———<code>Afred Aho</code>,<code>Peter Weinberger</code>与 <code>Brian Kernighan</code>。常见版本有：</p><ul><li><code>awk</code>： 最原初的版本，它由 AT&amp;T 实验室开发</li><li><code>nawk</code>：awk的改进增强版本</li><li><code>gawk</code>：GNU awk，所有的 GNU/Linux 发行版都包括gawk，且完全兼容awk与nawk</li></ul><a id="more"></a><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><blockquote><p>awk -v FS=”:” -v OFS=”,” ‘{print $1,$3}’ /etc/passwd</p></blockquote><p> 1.awk对文件或管道的内容一次只处理一行，将获取搭配的这一行赋值给内部变量$0<br> 2.将取到的一行的内容按awk内部变量FS定义的分割符（缺省为空格，包含tab制表符,上面的例子通过<code>-v</code>选项指定分解符为<code>：</code>为分隔符）分为多个字段，每一段存储在$1，$2…开始的变量中<br> 3.awk中print命令打印字段；{print $1,$3} 只取有用的第一段和第三段；在打印时$1和$3之间由空格间隔。“,”逗号是一个映射到内部的输出字段分隔符（OFS），OFS变量缺省为空格，例子中指定<code>，</code>为输出分隔符。接下来，awk处理下一行数据，直到所有的行处理完。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong><code>awk [option] program FILE1...</code></strong><br>program:<code>PATTERN{ACTION STATEMENTS}</code><br>字段说明：</p><blockquote><p><code>option</code>：常用选项有<code>-F</code>和<code>-v</code>等<br><code>program</code> :匹配并操作文本</p><ul><li><code>{action}</code>：每一次输入的行都会执行一次主体部分的命令</li><li><code>PATTERN</code>：限定对于输入的行的规则，可选</li></ul></blockquote><p>以下详细说明awk的各个字段…</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="option"><a href="#option" class="headerlink" title="option"></a>option</h3><blockquote><p><code>-F</code>：指明输入时用到的字段分隔符，默认为空白字符<br>-<code>v var=value</code>：自定义变量<br><code>-f</code>：读取文件中的awk规则</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk -v str=&apos;hello&apos; &apos;&#123;print str,$1&#125;&apos; file1       </span><br><span class="line">awk &apos;BEGIN&#123;str=&quot;hello&quot;&#125;&#123;print str,$1&#125;&apos; file1    # 效果同上</span><br><span class="line">awk -f file1                                    # awk规则写到脚本中读取</span><br></pre></td></tr></table></figure><h3 id="program"><a href="#program" class="headerlink" title="program"></a>program</h3><h4 id="1-PATTERN"><a href="#1-PATTERN" class="headerlink" title="1.PATTERN"></a>1.PATTERN</h4><blockquote><p> <code>empty</code>：空模式，匹配每一行<br>    <code>/regular expression/</code>：仅处理能够被此处的模式匹配到的行<br>    <code>relational expression</code>: 关系表达式；结果有“真”有“假”；结果为“真”才会被处理；真：结果为非0值，非空字符串；<br>     <code>line ranges</code>：行范围<br>    <code>startline,endline：/pat1/,/pat2/</code>   #指明起始行结束行模式  note： 不支持直接给出数字的格式</p><p><code>BEGIN/END</code>模式<br>    <code>BEGIN</code>{}: 仅在开始处理文件中的文本之前执行一次<br>    <code>END</code>{}：仅在文本处理完成之后执行一次</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;/UUID/&#123;print $1&#125;&apos; /etc/fstab   #处理匹配到UUID的行</span><br><span class="line">awk &apos;!/UUID/&#123;print $1&#125;&apos; /etc/fstab  #处理UUID以外的行</span><br><span class="line">awk -F : &apos;$3&lt;=500&#123;print $1&#125;&apos; /etc/passwd  #关系表达式匹配</span><br><span class="line"></span><br><span class="line">awk -F : &apos;$NF==&quot;/bin/bash&quot;&#123;print $1,$NF&#125;&apos; /etc/passwd       #关系表达是用法</span><br><span class="line">awk -F : &apos;$NF~/bash$/&#123;print $1,$NF&#125;&apos; /etc/passwd            #用模式匹配符匹配</span><br><span class="line">awk -F : &apos;/root/,/ftp/&#123;print $1,$NF&#125;&apos; /etc/passwd</span><br><span class="line">awk -F: &apos;(NR&gt;=2&amp;&amp;NR&lt;=10)&#123;print $1&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure><h4 id="2-常用action"><a href="#2-常用action" class="headerlink" title="2.常用action"></a>2.常用action</h4><p><strong>print</strong><br><code>print item1, item2, ...</code></p><p>要点：</p><ul><li>逗号分隔符；</li><li>输出的各item可以字符串，也可以是数值；当前记录的字段、变量或awk的表达式；</li><li>如省略item，相当于print $0; </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print &quot;line one\nline two\nline three&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p><strong>printf</strong><br>            格式化输出：<code>printf FORMAT, item1, item2, ...</code><br>要点：</p><ul><li>FORMAT必须给出 </li><li>不会自动换行，需要显式给出换行控制符，\n</li><li>FORMAT中需要分别为后面的每个item指定一个格式化符号</li></ul><blockquote><p>格式符：<br><code>%c</code>: 显示字符的ASCII码<br>                    <code>%d, %i</code>: 显示十进制整数<br>                    <code>%e, %E</code>: 科学计数法数值显示<br>                    <code>%f</code>：显示为浮点数<br>                    <code>%g, %G</code>：以科学计数法或浮点形式显示数值<br>                    <code>%s</code>：显示字符串<br>                    <code>%u</code>：无符号整数<br>                    <code>%%</code>: 显示%自身</p><blockquote><p>修饰符：<br>   <code>#[.#]</code>：第一个数字控制显示的宽度；第二个#表示小数点后的精度；<br>    <code>-</code> :  左对齐<br>    <code>+</code>：显示数值的符号</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &apos;&#123;printf &quot;%s\n&quot;,$1&#125;&apos; /etc/passwd </span><br><span class="line">awk -F: &apos;&#123;printf &quot;Username: %s\n&quot;,$1&#125;&apos; /etc/passwd</span><br><span class="line">awk -F : &apos;&#123;printf &quot;Username:%15s\n&quot;,$1&#125;&apos; /etc/passwd  #用修饰符控制输出字符的宽度</span><br><span class="line">awk -F : &apos;&#123;printf &quot;Username:%15s\n&quot;,$1&#125;&apos; /etc/passwd  #左对齐</span><br></pre></td></tr></table></figure><p><strong>操作符</strong></p><blockquote><p> 算术操作符：X<code>+</code>, <code>-</code>, <code>*</code>,<code>/</code>,<code>%</code>,<code>**</code>,<code>^</code> Y (X^Y Y为X的次方)<br>赋值操作符：X <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>**=</code>, <code>^=</code>, Y <code>++</code>,<code>--</code><br>比较操作符：X <code>&gt;</code>,<code>&gt;=</code>,<code>&lt;</code>,<code>&lt;=</code>,<code>==</code>,<code>!=</code>,<code>~</code>,<code>!~</code> Y<br>逻辑关系符：X <code>&amp;&amp;</code>,<code>||</code>Y<br>三元运算符：selector<code>?</code> if-true-exp<code>:</code> if-false-exp</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#输出系统用户</span><br><span class="line">awk -F: &apos;&#123;$3&gt;=1000?usertype=&quot;Common User&quot;:usertype=&quot;Sysadmin or SysUser&quot;;printf &quot;%15s:%-s\n&quot;,$1,usertype&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure><p><strong>条件控制</strong></p><ul><li><p>if-else： if (condition) {then-body} else {[ else-body ]}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &apos;&#123;if ($1==&quot;root&quot;) print $1, &quot;Admin&quot;; else print $1, &quot;Common User&quot;&#125;&apos; /etc/passwd</span><br><span class="line">awk -F: &apos;&#123;if ($1==&quot;root&quot;) printf &quot;%-15s: %s\n&quot;, $1,&quot;Admin&quot;; else printf &quot;%-15s: %s\n&quot;, $1, &quot;Common User&quot;&#125;&apos; /etc/passwd</span><br><span class="line">awk -F: -v sum=0 &apos;&#123;if ($3&gt;=500) sum++&#125;END&#123;print sum&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure></li><li><p>while：while (condition){statement1; statment2; …}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &apos;&#123;i=1;while (i&lt;=3) &#123;print $i;i++&#125;&#125;&apos; /etc/passwd</span><br><span class="line">awk -F: &apos;&#123;i=1;while (i&lt;=NF) &#123; if (length($i)&gt;=4) &#123;print $i&#125;; i++ &#125;&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure></li><li><p>do-while：do {statement1, statement2, …} while (condition)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &apos;&#123;i=1;do &#123;print $i;i++&#125;while(i&lt;=3)&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure></li><li><p>for：<br><code>for ( variable assignment; condition; iteration process) { statement1, statement2, ...}</code><br> <code>for (i in array) {statement1, statement2, ...}</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &apos;&#123;for(i=1;i&lt;=3;i++) print $i&#125;&apos; /etc/passwd</span><br><span class="line">awk -F: &apos;&#123;for(i=1;i&lt;=NF;i++) &#123; if (length($i)&gt;=4) &#123;print $i&#125;&#125;&#125;&apos; /etc/passwd</span><br><span class="line">awk -F: &apos;$NF!~/^$/&#123;BASH[$NF]++&#125;END&#123;for(A in BASH)&#123;printf &quot;%15s:%i\n&quot;,A,BASH[A]&#125;&#125;&apos; /etc/passwd</span><br></pre></td></tr></table></figure></li><li><p>case：<code>switch (expression) { case VALUE or /REGEXP/: statement1, statement2,... default: statement1, ...}</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN&#123;foo=0;switch(foo)&#123;case 0:print &quot;yes&quot;;break; case 1:print &quot;no&quot;;break; default: print &quot;unknow&quot;&#125;&#125;&apos;</span><br></pre></td></tr></table></figure></li><li><p>next：提前结束对本行文本的处理，并接着处理下一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: &apos;&#123;if($3%2==0) next;print $1,$3&#125;&apos; /etc/passwd    # 显示其ID号为奇数的用户</span><br></pre></td></tr></table></figure></li></ul><h2 id="awk高级应用"><a href="#awk高级应用" class="headerlink" title="awk高级应用"></a>awk高级应用</h2><p> <strong>内置变量</strong><br> <code>$0</code>：匹配到的行的全部字段<br><code>$1~$#</code>：匹配到行分割后的指定字段<br><code>NF</code>：number of field，字段个数<br><code>FS</code>：input field seperator，输入的分隔符，默认为空白字符<br><code>OFS</code>：output field seperator，输出的分隔符，默认为空白字符<br><code>RS</code>：input record seperator，输入的换行符<br><code>ORS</code>：output record seperator，输出时的换行符<br><code>NR</code>：number of record，当前记录的字段数，如果多文件时编号累加<br><code>FNR</code>：与NR不同的是，FNR用于记录正处理的行是当前这一文件中被总共处理的行数<br><code>FILENAME</code>：awk命令所处理的文件的名称</p><p> <strong>数组</strong><br><code>array[index]</code><br>index可以使用任意字符串，当某数据组元素不存在时，要引用其时，awk会自动创建此元素并初始化为空串，因此，要判断某数据组中是否存在某元素，需要使用index in array的方式。</p><ul><li>遍历：for (var in array) { statement1, … }</li><li>删除数组变量：delete array[index]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> # 每出现一被/^tcp/模式匹配到的行，数组S[$NF]就加1，NF为当前匹配到的行的最后一个字段，此处用其值做为数组S的元素索引；</span><br><span class="line"> netstat -ant | awk &apos;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&apos;    </span><br><span class="line"> </span><br><span class="line"> #统计某日志文件中IP地的访问量</span><br><span class="line">awk &apos;&#123;counts[$1]++&#125;; END &#123;for(url in counts) print counts[url], url&#125;&apos; /var/log/httpd/access_log</span><br></pre></td></tr></table></figure><p><code>ARGC</code>：命令行中参数的个数，其awk命令也算一个参数<br><code>ARGV</code>：其是一个数组，保存的是命令行所给定的各参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;&#123;print NF&#125;&apos; /etc/fstab         # 每行字段数，这里是数量引用，不是对应的值引用</span><br><span class="line">awk &apos;&#123;print $NF&#125;&apos; /etc/fstab        # 每行中的最后一个字段的值</span><br><span class="line">awk &apos;&#123;print NR&#125;&apos; file1 file2        # 会每把所有文档进行总的编号，而不是单独对文件进行编号</span><br><span class="line">awk &apos;&#123;print FNR&#125;&apos; file1 file2       # 会对每个文件的行数进行单独的编号显示</span><br><span class="line">awk &apos;&#123;print FILENAME&#125;&apos; file1        # 显示当前文件名，但会每行显示一次</span><br><span class="line">awk &apos;END&#123;print FILENAME&#125;&apos; file1     # 显示当前文件名，但只会显示一次</span><br><span class="line">awk &apos;END&#123;print ARGC&#125;&apos; /etc/fstab    # 显示共有几个参数</span><br></pre></td></tr></table></figure></p><p><strong>内置函数</strong></p><blockquote><p><code>rand()</code>：随机数，大于等于0，小于1<br><code>gsub(str1, str2, str)</code>：在str中将str1全部替换为str2，支持配符查找<br><code>index(str1, str2 )</code>：在str1内找首次出现str2出现的位置，没有则返回0<br><code>split(str,array[,fieldsep[,seps]])</code>：将str以fieldsep为分隔符分隔，并将结果保存至array数组中，下标为从0开始<br><code>length([str])</code>：返回string字符串中字符的个数<br><code>substr(str, start [, length])</code>：截取字符串，从start开始，取length个，start从1开始计数<br><code>system(command)</code>：执行系统命令并将结果返回至awk<br><code>systime()</code>：系统当前时间戳<br><code>mktime(&quot;YYYY MM DD HH MM SS[ DST]&quot;)</code>：指定日期时间戳，注意加引号<br><code>strftime(format [,timestamp [,utc-flage]])</code>：生成指定格式时间，具体格式参考date命令<br><code>tolower(str)</code>：转为小写<br><code>toupper(str)</code>：转为大写</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;BEGIN&#123;str=&quot;this is a test&quot;;split(str,A,&quot; &quot;);print length(A);for(i in A)&#123;print i,A[i];&#125;&#125;&apos;</span><br><span class="line">awk &apos;BEGIN&#123;str=&quot;str std str2&quot;;gsub(&quot;str&quot;,&quot;STR&quot;,str);print str&#125;&apos; </span><br><span class="line">awk &apos;BEGIN&#123;str=&quot;this is a test&quot;;b=match(str,&quot;is&quot;);print b&#125;&apos;</span><br><span class="line">awk &apos;BEGIN&#123;str=&quot;this is a test2016&quot;;print substr(str,4,6)&#125;&apos; </span><br><span class="line">netstat -ant | awk &apos;/:80\&gt;/&#123;split($5,clients,&quot;:&quot;);IP[clients[1]]++&#125;END&#123;for(i in IP)&#123;print IP[i],i&#125;&#125;&apos; | sort -rn | head -50</span><br><span class="line">awk &apos;BEGIN&#123;print mktime(&quot;2016 06 21 11 22 33&quot;)&#125;&apos;</span><br><span class="line">awk &apos;BEGIN&#123;print strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,systime())&#125;&apos;</span><br><span class="line">awk &apos;&#123;system(&quot;mkdir &quot; ($NF-1)&#125;&apos; filename    # 倒数第二个字段做为目录名创建目录</span><br></pre></td></tr></table></figure><p>以上内容参考马哥笔记。。。</p>]]></content>
      
      
      <categories>
          
          <category> Linux Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> awk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux文本处理三剑客之grep</title>
      <link href="/2018/04/23/grep%20using/"/>
      <url>/2018/04/23/grep%20using/</url>
      
        <content type="html"><![CDATA[<h2 id="grep简介"><a href="#grep简介" class="headerlink" title="grep简介"></a>grep简介</h2><p><strong>grep</strong>：英文缩写Global search Regular Expression and Print out the line(全面搜索正则表达式并把行打印出来)，是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。<br> <a id="more"></a></p><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式是对字符串操作的一种逻辑公式，用事先定义好的一组特殊字符，组成一个“规则字符集合”，根据用户指定的文本模式对目标文件进行逐行搜索匹配，显示能被模式匹配到的结果。</p><p>给定一个正则表达式和另一个目标字符串，我们可以从给定的字符串中通过匹配模型，过滤字符串中不想要的的字符串，得到目标字符串，减少工作量。</p><h3 id="正则表达式分类"><a href="#正则表达式分类" class="headerlink" title="正则表达式分类"></a>正则表达式分类</h3><p>GUN/linux下grep包括 grep、egrep和 fgrep</p><ul><li>egrep是grep的扩展，等同grep -E</li><li>fgrep就是fixed grep或fast grep，等同grep -F不使用任何正则表达式，直接进行字符串匹配</li></ul><p>常用的正则表达式一般为基本正则表达式grep和扩展正则表达式egrep。<br>扩展正则表达式与基础正则表达式的唯一区别在于：? + () {} 这几个字符。</p><p>基础正则表达式中，如果你想? + () {}表示特殊含义，你需要将他们转义,<br>而扩展正则表达式中，如果你想? + () {} 不表示特殊含义，你需要将他们转义。<br>如下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[echo@localhost]$ echo aaaa | grep  &apos;a?&apos;</span><br><span class="line">[echo@localhost]$ echo aaaa | grep  &apos;\a?&apos;</span><br><span class="line">aaaa</span><br><span class="line">[echo@localhost]$ echo aaaa | grep -E &apos;a?&apos;</span><br><span class="line">aaaa</span><br><span class="line">[echo@localhost]$ echo aaaa | egrep &apos; a?&apos;</span><br><span class="line">aaaa</span><br></pre></td></tr></table></figure></p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><strong><code>grep [OPTION] PATTERN [FILE]…</code></strong></p><blockquote><p><code>-o</code>：只显示被模式匹配到的内容<br><code>-i</code>：ignore case，不区分字符大小写<br><code>-E</code>：使用扩展的正则表达式<br><code>-w</code>：匹配一个完整的单词<br><code>-v</code>：没有匹配到的行<br><code>-n</code>：打印出匹配字符串的在文件中的行号<br><code>--color</code>：对匹配的字符串着色打印<br><code>-5</code>：匹配字符及前后各5行<br><code>-A 5</code>：匹配字符及后5行，同-C 5<br><code>-B 5</code>：匹配字符及前5行</p></blockquote><pre> grep -oin 'root' /etc/passwd   #显示行号，不区分大小写只匹配到字符本身</pre><h3 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h3><blockquote><p><code>.</code>：匹配任意单个字符<br><code>[]</code>：匹配指定范围内的任意单个字符<br><code>[^]</code>：匹配指定范围外的任意单个字符<br><code>[0-9]</code>：匹配数组 0-9 的任意一个<br><code>[0-z]</code>：匹配任一数字及小写字母<br><code>[0-Z]</code>：匹配任一数字及大小写字母<br><code>[[:digit:]]</code>：匹配任意单个数字<br><code>[[:lower:]]</code>：匹配任意单个小写字母，等同[a-z]<br><code>[[:upper:]]</code>：匹配任意单个大写字母，等同[A-Z]<br><code>[[:space:]]</code>：匹配任意单个空白字符<br><code>[[:punct:]]</code>：匹配任意单个标点符号<br><code>[[:alpha:]]</code>：匹配任意单个英文字母<br><code>[[:alnum:]]</code>：匹配任意单个字母或数</p></blockquote><pre>grep  [^0-9[:lower:]]  /etc/passwd      # 匹配除数字和小写字母以外的字符</pre><h3 id="匹配次数"><a href="#匹配次数" class="headerlink" title="匹配次数"></a>匹配次数</h3><blockquote><p><code>*</code>: 匹配前面的字符任意次<br><code>.*</code>：匹配任意次 ，即匹配任意长度的任意字符<br><code>\?</code> ：匹配前面的字符 0 次或者 1 次<br><code>\+</code>： 匹配前面的字符 1 次或多次<br><code>\{m\}</code>：匹配前面的字符 m 次<br><code>\{m,n\}</code>：匹配前面的字符至少 m 次，至多 n 次<br><code>\{m,\}</code>：匹配前面的字符至少 m 次<br><code>\{,n\}</code>：匹配前面的字符至多 n 次</p></blockquote><pre>grep "[0-9]\+.*[[:punct:]]\{3,\}" /etc/passwd    # 至少一个数字及3个以上标点符号</pre><h3 id="位置锚定"><a href="#位置锚定" class="headerlink" title="位置锚定"></a>位置锚定</h3><blockquote><p><code>^</code>：锚定行首<br><code>$</code>：锚定行尾<br><code>\&lt;</code> 或 <code>\b</code>：锚定词首<br><code>\&gt;</code> 或 <code>\b</code>：锚定词尾</p></blockquote><pre>grep -n "^[[:space:]]\+$" mydata.txt                  # 找出空白行的行号grep "^#[[:space:]]\{1,\}[^[:space:]]" /etc/inittab   # 以#开头，且后面跟一个或多个空白字符，而后又跟了任意非空白字符的行grep '^\([0-9]\).*\1$' /etc/inittab                   # 一个数字开头并以一个与开头数字相同的数字结尾的行</pre><h3 id="分组引用"><a href="#分组引用" class="headerlink" title="分组引用"></a>分组引用</h3><blockquote><p>以使用括号<code>\(***\)</code>将一组字符括起来，表示这一组字符被当作一个整体，还可以使用 \1, \2… 对前面括号匹配所匹配的字符串进行引用</p></blockquote><pre># 首个单词和最后一个单词一样的行grep "^\(\<[[:alpha:]]\+\>\).*\1$" /etc/passwd  # 匹配包含mysql或apache或redis的行，`|`表示或  egrep "mysql|apache|redis" mydata.txt  # 匹配ipv4的地址  egrep "(\<([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\>\.){3}\<([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[05])\>"  # 取出默认shell为bash，且其用户ID号最小的用户的用户名  grep 'bash$' /etc/passwd | sort -n -t: -k3 | head -1 | cut -d: -f1</([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[05])\></([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\></[[:alpha:]]\+\></pre>]]></content>
      
      
      <categories>
          
          <category> Linux Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> grep </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux软硬链接</title>
      <link href="/2018/04/23/link/"/>
      <url>/2018/04/23/link/</url>
      
        <content type="html"><![CDATA[<h2 id="linux文件与目录"><a href="#linux文件与目录" class="headerlink" title="linux文件与目录"></a>linux文件与目录</h2><p>现代操作系统为解决信息能独立于进程之外被长期存储引入了文件，文件作为进程创建信息的逻辑单元可被多个进程并发使用。在 UNIX 系统中，操作系统为磁盘上的文本与图像、鼠标与键盘等输入设备及网络交互等 I/O 操作设计了一组通用 API，使他们被处理时均可统一使用字节流方式。换言之，UNIX 系统中除进程之外的一切皆是文件，而 Linux 保持了这一特性。为了便于文件的管理，Linux 还引入了目录（有时亦被称为文件夹）这一概念。目录使文件可被分类管理，且目录的引入使 Linux 的文件系统形成一个层级结构的目录树。<br><a id="more"></a></p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjg5uy2jj30yn12kwkq.jpg" alt="enter description here"></p><h2 id="linux文件系统数据的存储与读取"><a href="#linux文件系统数据的存储与读取" class="headerlink" title="linux文件系统数据的存储与读取"></a>linux文件系统数据的存储与读取</h2><p>我们知道文件都有文件名与数据，linux采用索引式文件系统（indexed allocation），将其分成两个部分存放：</p><blockquote><p>元数据 (meta data)：数据块是记录文件真实内容的地方文件的附加属性，如文件大小、创建时间、所有者等信息， 文件权限（rwx）与文件属性（拥有者、群组、时间参数等）。<br>用户数据 (user data) ：即文件数据块 (data block)，数据块是记录文件真实内容的地方；</p></blockquote><p>在 Linux 中，<code>元数据</code>中又被分为以下两部分：</p><blockquote><p>inode 号：（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）才是文件的唯一标识而非文件名。<br>文件名：为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。</p></blockquote><p>使用<code>文件名</code>来读取数据：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjgdd31ij30hh08mjri.jpg" alt="enter description here"></p><p>为解决文件的共享使用，Linux 系统引入了两种链接：硬链接 (hard link) 与软链接（又称符号链接，即 soft link 或 symbolic link）。链接为 Linux 系统解决了文件的共享使用，还带来了隐藏文件路径、增加权限安全及节省存储等好处。</p><blockquote><p>如果一个 inode 号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名hard link 就是 file 的一个别名，他们有共同的 inode。<br>如果一个文件存放着指向另一个文件的路径名的指向，则称作软链接（类似window操作系统下的快捷方式）。软链接就是一个普通文件，只是数据块内容有点特殊。软链接有着自己的 inode 号以及用户数据块。</p></blockquote><p>通过<code>链接</code>读取数据：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjgjziqhj30h20bnq3c.jpg" alt="enter description here"></p><h2 id="软链接和硬链接特性及比较"><a href="#软链接和硬链接特性及比较" class="headerlink" title="软链接和硬链接特性及比较"></a>软链接和硬链接特性及比较</h2><h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p><strong>硬链接是有着原文件相同 inode 号仅文件名不同的文件</strong>。因此硬链接存在以下几点特性：</p><ul><li>文件有相同的 inode 及 data block；</li><li>只能对已存在的文件进行创建；</li><li>不能交叉文件系统进行硬链接的创建；</li><li>不能对目录进行创建，只可对文件创建；</li><li><p>删除一个硬链接文件并不影响其他有相同 inode号的文件。</p><h3 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h3><p><strong>软链接是文件用户数据块中存放的内容是另一文件的路径名的指向</strong>。因此软连接存在以下几点特性：</p></li><li><p>软链接有自己的文件属性及权限等；</p></li><li>可对不存在的文件或目录创建软链接；</li><li>软链接可交叉文件系统；</li><li>软链接可对文件或目录创建；</li><li>创建软链接时，链接计数 i_nlink 不会增加；</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>根据以上两种链接的特性，总结以下区别</p><table><thead><tr><th>-</th><th>软链接</th><th>硬链接</th></tr></thead><tbody><tr><td>文件属性是否独立</td><td>是</td><td>否</td></tr><tr><td>对不存在的文件创建链接</td><td>是</td><td>否</td></tr><tr><td>可交叉文件系统</td><td>是</td><td>否</td></tr><tr><td>对目录创建链接</td><td>是</td><td>否</td></tr><tr><td>删除链接对原文件影响</td><td>否</td><td>否</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链接文件是Linux文件系统上的一个优势，链接是一种虚拟的副本，是目录中指向文件真实位置的占位符。</p>]]></content>
      
      
      <categories>
          
          <category> Linux Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> link </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes基本概念</title>
      <link href="/2018/03/16/Kubernetes_concepts/"/>
      <url>/2018/03/16/Kubernetes_concepts/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes是基于Google内部的容器编排系统Borg的开源实现，早在很久以前，Google就开始使用Borg容器编排系统承载Google的全部业务。在Docker容器之上，它使用label和pod的概念来将容器换分为逻辑单元。Pods是同地协作（co-located）容器的集合，这些容器被共同部署和调度，形成了一个服务，这是Kubernetes和其他容器编排系统的只要区别，这种逻辑概念在现在验证来看确实是最佳实践。下面我们从Kubernetes基本概念入手，开始Kubernetes之旅。</p><h2 id="1-1-Master"><a href="#1-1-Master" class="headerlink" title="1.1 Master"></a>1.1 Master</h2><p>在Kubernetes集群中和大多数集群一样，需要一个强大的领导者，来管理和控制集群，这个管理者就是Master。在Master上运行的几个关键的进程，分工合作，管理着集群：</p><ul><li><p>Kubernetes API  Server （kube-apiserver）提供了HTTP Restful 接口风格的关键服务进程，是Kubernetes中资源的增、删、改、查操作的统一入口，集群管理kubectl直接和API Server交互。</p></li><li><p>Kubernetes Controller Mananger （kube-controller-manager）如果说API  Server 是负责前台工作的话，那Controller Manager则是负责后台的。当用户要创建一个Pod时，kubectl 先跟API Server交互创建，当Pod创建完成后，APIServer的任务就算完成了，而后期Pod的状态和我们所期望的状态就需要Controller Mananger去保证了。</p></li><li><p>Kubernetes Scheduler （kube-scheduler） scheduler 的工作很明确，负责把Pod根据调度到合适的Node上，如果把scheduler 比作一个黑匣子，输入Pod和Node组成的列表，输出的是Pod对应Node的列表，即Pod被部署到哪个Node上，Kubernetes提供了调度算法，同时保留了用户自定义算法的接口。</p><p>在Kubernetes服务之外，还要将所有资源对象的数据保存到etcd中。</p><a id="more"></a><h2 id="1-2-Node"><a href="#1-2-Node" class="headerlink" title="1.2 Node"></a>1.2 Node</h2></li></ul><p>除了Mater节点外，当然还要有集群中真正干活的了，这就是Node。通常也叫它负载节点，Node负责容器运行，Master节点负责管理控制，当某个Node宕机时，其上面的应用会被调度到其他Node上，实现HA。</p><p>Node上也运行着一些关键进程：</p><ul><li><p>Kubelet kubelet是Master 在每个Node节点上的agent，负责Node节点上的Pod的创建、启动，它负责维护和管理该Node上面的所有容器，但是如果容器不是通过Kubernetes创建的，它并不会管理。本质上，它负责使Pod得运行状态与期望的状态一致。</p></li><li><p>Kube-proxy 该模块实现了Kubernetes中的服务发现和反向代理功能。反向代理：kube-proxy支持TCP和UDP连接转发，默认基于Round Robin算法将客户端流量转发到与service对应的一组后端Pod。服务发现：kube-proxy使用etcd的watch机制，监控集群中service和endpoint对象数据的动态变化，并且维护一个service到endpoint的映射关系，从而保证了后端Pod重启的IP变化不会对访问者造成影响。另外kube-proxy还支持session affinity来保证session的一致性。</p></li><li><p>Container Runtime 容器运行时，Kubernetes采用插件式的设计风格，后端不依赖于具体的容器引擎，Kubernetes目前支持常见的容器引擎rkt和docker，在未来可能绕过docker中间层，直接支持Container Runtime：<a href="https://containerd.io/" target="_blank" rel="noopener">containerd</a>，可能带来的是性能上的提升，值得期待。</p></li></ul><p>  至此，我们可以很清晰认识Kubernetes物理架构图：</p><p>  <img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1h3oaju37j30cl0bijrs.jpg" alt="kubernetes_Strcuture"></p><p>  下面就来介绍 Kubernetes 中资源对象：</p><h2 id="2-Pod"><a href="#2-Pod" class="headerlink" title="2. Pod"></a>2. Pod</h2><p>  Pod是kubernetes 中重要的概念，基本的操作单位，如果把Kubernetes类比一个云操作系统的话，那Pod就是运行在集群中的一个”进程“。Pod是容器的集合，它把应用装入到到一组相关容器中，容器间共享资源，拥有在一个名称空间中唯一的IP，以及维持容器运行的其他资源，而容器更像是进程中的“线程”。</p><p>  在Kubernetes应用部署时，以Pod为一个部署单元，应用程序的单个实例可能由单个容器组成，也可能由一些紧密相关的容器组成。</p><p>  下图是一个实例：</p><p>  <img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1h3omw4obj30eg0edabb.jpg" alt="pod"></p><p>包含文件读取和一个Web服务器多容器的一个Pod，该服务器和其他应用，使用一个持久卷进行容器之间的共享存储</p><p><strong>Kubernetes 引入 Pod 主要基于下面两个目的：</strong></p><ul><li><p>方便管理：Pod通过提供比其组成应用程序更高级别的抽象，简化应用程序部署和管理。以Pod为部署单元，它解决了容器水平扩展和复制、共同调度，生命周期，协调复制，资源共享和依赖性管理等问题。</p></li><li><p>资源共享和容器间通信：应用在Pod中使用相同的名称空间（相同的IP和Port），使用<code>localhost</code>就能相互通信，在Pod与Pod之间，每个Pod都有一个IP地址，可与整个网络中的其他Pod进行通信。</p></li></ul><h2 id="3-Controller"><a href="#3-Controller" class="headerlink" title="3. Controller"></a>3. Controller</h2><h3 id="3-1-Replication-Controller"><a href="#3-1-Replication-Controller" class="headerlink" title="3.1 Replication Controller"></a>3.1 Replication Controller</h3><p>  RC确保在任意时间保证Pod的数量，或者说RC保证在Pod创建后，在任意一时间都是可用的。当在Kubernetes集群中有很多Pods时，当Pod因失败，数量增加或减少时，不同于手动创建Pod的方式，RC会自动增加或减少Pod达到预期的数量。如果把它比作进程管理着，那RC监控着多个节点上的多个Pod。在此基础上，RC还提供了一些更高级的特性，比如滚动升级、升级回滚等。</p><h3 id="3-1-ReplicaSet"><a href="#3-1-ReplicaSet" class="headerlink" title="3.1 ReplicaSet"></a>3.1 ReplicaSet</h3><p>  ReplicaSet 是下一代的Replication Controller，不同之处在于ReplicaSet 在原有的基础加入了选择器的支持，实现了 Pod 的多副本管理。使用 Deployment 时会自动创建 ReplicaSet，也就是说 Deployment 是通过 ReplicaSet 来管理 Pod 的多个副本的，通常不需要我们直接使用 ReplicaSet。</p><h3 id="3-2-Job"><a href="#3-2-Job" class="headerlink" title="3.2 Job"></a>3.2 Job</h3><p>  就像它名字来一样，它代表着一次任务，与之相关联的Pod分为两种：其他Controller创建的是长期的Pod，Job创建是临时的Pod，该Pod在任务完成后删除。</p><p>同时Job可以控制一次性任务的Pod的完成次数<code>.Job.spec.completions</code>和并发执行数<code>.Job.spec.parallelism</code>，当Pod成功执行指定次数后，即认为Job执行完毕。在<code>.spec.template.spec.restartPolicy</code>  （重启策略）中，只能是Never和OnFailure。</p><h3 id="3-3-Deployments"><a href="#3-3-Deployments" class="headerlink" title="3.3 Deployments"></a>3.3 Deployments</h3><p>Deployment是最常用的Controller，当我们用yml文件去描述想要的Pod 的状态，Deployment controller 就会帮我们将 Pod 和ReplicaSet 的实际状态改变到我们所描述的目标状态。</p><h3 id="3-4-StatefulSets"><a href="#3-4-StatefulSets" class="headerlink" title="3.4 StatefulSets"></a>3.4 StatefulSets</h3><p>Pod调度运行时，如果应用不需要任何稳定的标示、有序的部署、删除和扩展，则只需要使用一组无状态副本的控制器来部署应用，这样的Controller有：Deployment、ReplicaSet，这样的Controller更适合无状态服务需求。当我们需要Pod在重启后名称不变，并按照一定顺序去部署或者删除我们的Pod时，这就需要StatefulSets了。</p><p>使用StatefulSets时，具有以下特点：</p><ul><li><p>稳定性，唯一的网络标识符</p></li><li><p>稳定性，持久化存储</p></li><li>有序的部署和扩展</li><li>有序的删除和终止</li><li>有序的自动滚动更新</li></ul><p>这样更好的应对在更复杂的场景需求。</p><h3 id="3-5-DaemonSet"><a href="#3-5-DaemonSet" class="headerlink" title="3.5 DaemonSet"></a>3.5 DaemonSet</h3><p>DaemonSet保证每一个Node节点上，运行着一个和其他节点上相同的副本Pod，当在集群中增加或减少Node节点时，在该节点上Pods也会被部署或删除，当删除DaemonSet时每个节点上的Pod会被清理 。</p><p>下面列举几个应用的场景：集群中每个Node上用于存储的守护进程，如<code>gluster</code> <code>ceph</code>；收集日志的守护进程，如<code>fluentd</code> <code>logstash</code>等。</p><h2 id="4-Label"><a href="#4-Label" class="headerlink" title="4 Label"></a>4 Label</h2><p>Label是另一个核心的概念 ，Label是一个k-v的键值对，由于它的灵活性，Label可以很轻松的附加都各种资源上，一个资源对象可以定义任意数量的Label，同一个Label可以添加到任意数量的资源对象上去。这样我们就可以给指定的Label来实现 多维度的资源管理分组等功能。</p><p>Label Selector 在Kubernetes中的使用场景有以下几处：</p><ul><li>kube-controller进程通过资源对象RC上定义的Label Selector来筛选要监控的Pod 的副本数量，从而实现Pod副本的数量始终符合预期设定的数目。</li><li>kube-proxy 进程通过Service的Label Selector来选择对应的Pod，自动建立每个Service对应Pod的请求转发路由表，从而实现负载均衡。</li><li>通过对某个Node定义特定的Label，并且在Pod定义文件yml 中使用NodeSelector 这种标签调度策略，kube-schedular 进程可以实现Pod的定向调度的特性。</li></ul><h2 id="5-Service"><a href="#5-Service" class="headerlink" title="5 Service"></a>5 Service</h2><p>在Kubernetes中Pod 是有生命周期的，它们可以被创建，也可以被销毁，然而一旦被销毁生命就永远结束。 通过 ReplicationController 能够动态地创建和销毁 Pod。当进行扩缩容， 滚动升级时。 每个 Pod 都会获取它自己的 IP 地址，这些 IP 地址总是不固定的。这会导致一个问题：在 Kubernetes 集群中，如果一组 Pod（称为 backend）为其它 Pod （称为 frontend）提供服务，那么那些 frontend 该如何发现，并连接到这组 Pod 中的哪些 backend 呢？答案就是Service。</p><p>Kubernetes Service 定义了这样一种抽象：一个 Pod 的逻辑分组，一种可以访问它们的策略 —— 通常称为微服务。</p><p>Pod的EndPoint（ContainerPort+Pod IP）地址会随着Pod的销毁和创建而发生改变，而Service一旦创建，Kubernetes就会自动为它分配一个固定的、唯一的虚拟IP （Cluster IP），在Service的整个周期内Cluster IP不会改变。Kubernetes<strong>服务发现</strong>的问题，就很好的解决了，同时还为 Pod 提供了负载均衡。</p><p>Pod、 RC 与Service的逻辑关系 </p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1h3oykwodj30qo0k00te.jpg" alt="Service">当前端的Pod需要访问另一组Pod时，Service定义了一个服务的访问入口地址，通过这个入口访问其背后的由一组Pod副本所组成的实例，Service与其后端则是通过根据Label Selector来实现从多个Pod中选取所期望的Pod，RC保证Service的服务能力和服务的质量达到预期的标准。</p><h2 id="6-Namespace"><a href="#6-Namespace" class="headerlink" title="6 Namespace"></a>6 Namespace</h2><p>在Kubernetes中可以使用Namespaces（命名空间）创建多个虚拟集群。当团队或项目中具有许多用户时，可以考虑使用Namespace来区分，如果是少量用户集群，可以不需要考虑使用Namespace，如果需要它们提供特殊性质时，可以开始使用Namespace。Namespace为名称提供了一个范围。资源的Names在Namespace中具有唯一性。在未来的Kubernetes版本中，默认情况下，相同Namespace中的对象将具有相同的访问控制策略。</p><p>在理解理清这些概念后，还需要在以后在使用Kubernetes中更深入的理解这些概念。</p><p>参考</p><p>《Kubernetes权威指南》</p><p><a href="https://kubernetes.io/docs/home/?path=users&amp;persona=app-developer&amp;level=foundational" target="_blank" rel="noopener">Kubernetes document</a></p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>_,ok模式</title>
      <link href="/2018/02/27/ok_pattern/"/>
      <url>/2018/02/27/ok_pattern/</url>
      
        <content type="html"><![CDATA[<p>我们经常在一个表达式返回2个参数时使用这种模式：<code>_，ok</code>，第一个参数是一个值或者<code>nil</code>，第二个参数是<code>true</code>/<code>false</code>或者一个错误<code>error</code>。在一个需要赋值的<code>if</code>条件语句中，使用这种模式去检测第二个参数值会让代码显得优雅简洁。这种模式在go语言编码规范中非常重要。下面总结了所有使用这种模式的例子：</p><ul><li>在函数返回时检测错误:</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">value, err := pack1.Func1(param1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Printf(“Error %s in pack1.Func1 with parameter %v”, err.Error(), param1)</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数Func1没有错误:</span></span><br><span class="line">Process(value)</span><br><span class="line"></span><br><span class="line">e.g.: os.Open(file) strconv.Atoi(str)</span><br></pre></td></tr></table></figure><a id="more"></a><p>这段代码中的函数将错误返回给它的调用者，当函数执行成功时，返回的错误是<code>nil</code>，所以使用这种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">SomeFunc</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">if</span> value, err := pack1.Func1(param1); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        …</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    …</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种模式也常用于通过<code>defer</code>使程序从<code>panic</code>中恢复执行。</p><p>要实现简洁的错误检测代码，更好的方式是使用闭包。</p><ul><li>检测映射中是否存在一个键值：<code>key1</code>在映射<code>map1</code>中是否有值？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value, isPresent = map1[key1]; isPresent &#123;</span><br><span class="line">        Process(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// key1不存在</span></span><br><span class="line">…</span><br></pre></td></tr></table></figure><ul><li>检测一个接口类型变量<code>varI</code>是否包含了类型<code>T</code>：类型断言：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> value, ok := varI.(T); ok &#123;</span><br><span class="line">    Process(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口类型varI没有包含类型T</span></span><br></pre></td></tr></table></figure><ul><li>检测一个通道<code>ch</code>是否关闭：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> input := <span class="keyword">range</span> ch &#123;</span><br><span class="line">    Process(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> input, open := &lt;-ch; !open &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// 通道是关闭的</span></span><br><span class="line">    &#125;</span><br><span class="line">    Process(input)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defer模式</title>
      <link href="/2018/02/27/derfer_pattern/"/>
      <url>/2018/02/27/derfer_pattern/</url>
      
        <content type="html"><![CDATA[<p>在golang中使用<code>defer</code>确保全部的资源正确的关闭，或者把不使用的资源返回到<code>pool</code>中，其次更重要的是从<code>panicing</code>中<code>recovering</code>。下面总结了所有使用这种模式的例子：</p><ul><li>关闭文件流</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// open a file f</span></span><br><span class="line"><span class="keyword">defer</span> f.Cloes()</span><br></pre></td></tr></table></figure><ul><li>给加锁的资源解锁</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mu.lock()</span><br><span class="line"><span class="keyword">defer</span> mu.Unlock()</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>关闭一个channel（如果有必要的话）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">float64</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure><p>或者两个chanel:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">answer1,answer2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>),<span class="built_in">make</span> (<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123; <span class="built_in">close</span>(answer1);<span class="built_in">close</span>(answer2) &#125;()</span><br></pre></td></tr></table></figure></p><ul><li>从<code>panicing</code>中<code>recover</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>();err != <span class="literal">nil</span>&#123;</span><br><span class="line">        log.Printf(<span class="string">"run time panic: %v"</span>,err)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>停止一个定时器<code>Tciker</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ticker := time.NewTicker(updateInterval)</span><br><span class="line"><span class="keyword">defer</span> ticker.Stop()</span><br></pre></td></tr></table></figure><ul><li>释放一个进程</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p,err := os.StartProcess(..,..,..)</span><br><span class="line"><span class="keyword">defer</span> p.Release()</span><br></pre></td></tr></table></figure><ul><li>停止CPU分析并刷新信息</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pprof.StartCPUProfile(f)</span><br><span class="line"><span class="keyword">defer</span> pprof.StopCPUProfile()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zabbix自定义item key</title>
      <link href="/2018/02/23/zabbix%E8%87%AA%E5%AE%9A%E4%B9%89key/"/>
      <url>/2018/02/23/zabbix%E8%87%AA%E5%AE%9A%E4%B9%89key/</url>
      
        <content type="html"><![CDATA[<p>zabbix支持自定义用户item key，本文以收集系统内存数据为例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# free </span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:         999964      116132      336676       13316      547156      688392</span><br><span class="line">Swap:       2097148           0     2097148</span><br></pre></td></tr></table></figure></p><p>使用即可<code>free | awk &#39;/Mem/ {print $3}&#39;</code>收集使用内存数据<br><a id="more"></a></p><h3 id="1-确认文件导入主配置文件"><a href="#1-确认文件导入主配置文件" class="headerlink" title="1.确认文件导入主配置文件"></a>1.确认文件导入主配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# sed -n &apos;/^Include/p&apos; /etc/zabbix/zabbix_agentd.conf </span><br><span class="line">Include=/etc/zabbix/zabbix_agentd.d/*.conf  # agent配置文件默认开启</span><br></pre></td></tr></table></figure><h3 id="2-添加配置文件"><a href="#2-添加配置文件" class="headerlink" title="2.添加配置文件"></a>2.添加配置文件</h3><p><code>vim /etc/zabbix/zabbix_agentd.d/os.conf</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserParameter=os.memory.total,free | awk &apos;/Mem/ &#123;print $2&#125;&apos;</span><br><span class="line">UserParameter=os.memory.used,free | awk &apos;/Mem/ &#123;print $3&#125;&apos;</span><br><span class="line">UserParameter=os.memory.free,free | awk &apos;/Mem/ &#123;print $4&#125;&apos;</span><br></pre></td></tr></table></figure></p><h3 id="3-添加items，配置图表显示"><a href="#3-添加items，配置图表显示" class="headerlink" title="3.添加items，配置图表显示"></a>3.添加items，配置图表显示</h3><p><code>Configuration</code>–&gt;<code>Hosts</code>–&gt;<code>Items</code>–&gt;<code>Create item</code></p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk6f7wwbj313j0fvq5d.jpg" alt="enter description here"></p><p>自定义视图即可显示：<br><code>Configuration</code>–&gt;<code>Hosts</code>–&gt;<code>Graphs</code>–&gt;<code>Create graph</code></p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk6o757uj313x0p3q7k.jpg" alt="enter description here"></p><p>查看图表：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk6vpiuij31610go11b.jpg" alt="enter description here"></p>]]></content>
      
      
      <categories>
          
          <category> zabbix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>斐波那契数列</title>
      <link href="/2018/01/25/fibonacci/"/>
      <url>/2018/01/25/fibonacci/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>费波那契数列（意大利语：<code>Successione di Fibonacci</code>），又译为费波拿契数、斐波那契数列、费氏数列、黄金分割数列。<br>在数学上，费波那契数列是以递归的方法来定义：</p><ul><li><code>F0 = 0</code></li><li><code>F1 = 1</code></li><li><code>Fn = Fn-1 + Fn-2(n&gt;=2)</code></li></ul><p>用文字来说，就是费波那契数列由0和1开始，之后的费波那契系数就是由之前的两数相加而得出。首几个费波那契系数是：<br>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233……（OEIS中的数列A000045）<br><a id="more"></a></p><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//recursive</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span><span class="params">(res <span class="keyword">int64</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> n &lt;=  <span class="number">1</span>&#123;</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        res = fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Non-recursive</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib2</span><span class="params">(n <span class="keyword">int</span>)</span><span class="params">(res <span class="keyword">int64</span>)</span></span>&#123;</span><br><span class="line">    i,a,b := <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">        a,b = b,a+b</span><br><span class="line">        i ++</span><br><span class="line">        res = <span class="keyword">int64</span>(a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代算法中存在大量重复计算的情况，可以通过内存缓存来提升性能。<br>在内存中声明一个数组来对计算过的<code>fib(n)</code>值进行缓存，在计算时先查数组。<br>此处为了方便，申明的数组<code>fibs[n]</code>，数组下标为n的值，数组元素为值。</p><p>优化后代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//recursive and cache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib3</span><span class="params">(n <span class="keyword">int</span>)</span><span class="params">(res <span class="keyword">int64</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> fibs[n] != <span class="number">0</span>&#123;</span><br><span class="line">        fmt.Println(<span class="string">"geting in cache"</span>)</span><br><span class="line">        res = fibs[n]</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n &lt;=  <span class="number">1</span>&#123;</span><br><span class="line">        res = <span class="number">1</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        res = fib3(n<span class="number">-1</span>) + fib3(n<span class="number">-2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    fibs[n] = res</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>运行时间：</p><blockquote><p>//recursive<br>longCalculation took this amount of time: 23.9988484s</p></blockquote><blockquote><p>//Non-recursive<br>longCalculation took this amount of time: 0s</p></blockquote><blockquote><p>// recursive and cache<br>longCalculation took this amount of time: 987.6µs</p></blockquote><p>完整测试代码：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> fibtest <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int64</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">const</span> <span class="title">LIM</span> = 55</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">var</span> <span class="title">fibs</span> [<span class="title">LIM</span>]<span class="title">int64</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">//<span class="title">recursive</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">fib</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">res = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Non-recursive</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib2</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line">i, a, b := <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">a, b = b, a+b</span><br><span class="line">i ++</span><br><span class="line">res = <span class="keyword">int64</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//recursive and cache</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib3</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">(res <span class="keyword">int64</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> fibs[n] != <span class="number">0</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"geting in cache"</span>)</span><br><span class="line">res = fibs[n]</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">res = <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">res = fib3(n<span class="number">-1</span>) + fib3(n<span class="number">-2</span>)</span><br><span class="line">&#125;</span><br><span class="line">fibs[n] = res</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(f fibtest, n <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">start := time.Now()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">res := f(i)</span><br><span class="line">fmt.Printf(<span class="string">"fibonacci(%d) is: %d\n"</span>, i, res)</span><br><span class="line">&#125;</span><br><span class="line">end := time.Now()</span><br><span class="line">delta := end.Sub(start)</span><br><span class="line">fmt.Printf(<span class="string">"longCalculation took this amount of time: %s\n"</span>, delta)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">times := <span class="number">50</span></span><br><span class="line"><span class="comment">//recursive testing</span></span><br><span class="line"><span class="comment">//test(fib,times)</span></span><br><span class="line">test(fib3, times)</span><br><span class="line"></span><br><span class="line"><span class="comment">//non-recursive testing</span></span><br><span class="line"><span class="comment">//test(fib2,times)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux文件时间参数atime，ctime，mtime</title>
      <link href="/2018/01/23/linux%E6%97%B6%E9%97%B4%E5%8F%82%E6%95%B0/"/>
      <url>/2018/01/23/linux%E6%97%B6%E9%97%B4%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="linux时间参数atime-、mtime、ctime"><a href="#linux时间参数atime-、mtime、ctime" class="headerlink" title="linux时间参数atime 、mtime、ctime"></a>linux时间参数atime 、mtime、ctime</h3><p><code>Access（atime）</code>：访问时间，指文件最后一次被访问的时间；<br><code>Modify（mtime）</code>：修改时间，指文件内容最后一次被修改的时间。这里的文件内容指文件内的数据；<br><code>Change（ctime）</code>：状态修改时间，指文件的属性状态一次被修改的时，比如文件权限、所有者、大小等；<br><a id="more"></a><br>查看文件时间戳命令stat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@cloudhost ~]# stat a</span><br><span class="line">  File: ‘a’</span><br><span class="line">  Size: 0         Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: fd01h/64769dInode: 1557836     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2017-09-13 15:07:15.034441767 +0800  #文件访问时间(ctime)</span><br><span class="line">Modify: 2017-09-13 15:07:15.034441767 +0800  #文件内容修改时间(mtime)</span><br><span class="line">Change: 2017-09-13 15:07:15.034441767 +0800  #文件元数据修改时间(ctime)</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><h3 id="尝试使用"><a href="#尝试使用" class="headerlink" title="尝试使用"></a>尝试使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@cloudhost ~]# stat a</span><br><span class="line">  File: ‘a’</span><br><span class="line">  Size: 0         Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: fd01h/64769dInode: 1557836     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2017-09-13 15:07:15.034441767 +0800</span><br><span class="line">Modify: 2017-09-13 15:07:15.034441767 +0800</span><br><span class="line">Change: 2017-09-13 15:07:15.034441767 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"> </span><br><span class="line">[root@cloudhost ~]# cat a   #查看a文件，其他查看命令类似</span><br><span class="line"></span><br><span class="line">[root@cloudhost ~]# stat a</span><br><span class="line">  File: ‘a’</span><br><span class="line">  Size: 0         Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: fd01h/64769dInode: 1557836     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2017-09-13 15:07:39.892069721 +0800  #访问时间发生改变</span><br><span class="line">Modify: 2017-09-13 15:07:15.034441767 +0800</span><br><span class="line">Change: 2017-09-13 15:07:15.034441767 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><p>当再次查看时。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@cloudhost ~]# cat a</span><br><span class="line">[root@cloudhost ~]# stat a</span><br><span class="line">  File: ‘a’</span><br><span class="line">  Size: 0         Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: fd01h/64769dInode: 1557836     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2017-09-13 15:07:39.892069721 +0800   #访问时间不变</span><br><span class="line">Modify: 2017-09-13 15:07:15.034441767 +0800</span><br><span class="line">Change: 2017-09-13 15:07:15.034441767 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure></p><p>说好的最后一次访问时间呢？<br>通过echo命令在a里加数据…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@cloudhost ~]# echo &apos;welcome to echo &apos;&gt; a</span><br><span class="line">[root@cloudhost ~]# stat a</span><br><span class="line">  File: ‘a’</span><br><span class="line">  Size: 17        Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769dInode: 1557836     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2017-09-13 15:07:39.892069721 +0800</span><br><span class="line">Modify: 2017-09-13 15:14:23.372029181 +0800   #修改文件内容，mtime改变</span><br><span class="line">Change: 2017-09-13 15:14:23.372029181 +0800   #文件size(属性)改变，ctime改变</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure></p><p>再次查看文件。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@cloudhost ~]# cat a</span><br><span class="line">welcome to echo </span><br><span class="line">[root@cloudhost ~]# stat a</span><br><span class="line">  File: ‘a’</span><br><span class="line">  Size: 17        Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769dInode: 1557836     Links: 1</span><br><span class="line">Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2017-09-13 15:16:45.867896895 +0800   #访问的时间改变</span><br><span class="line">Modify: 2017-09-13 15:14:23.372029181 +0800</span><br><span class="line">Change: 2017-09-13 15:14:23.372029181 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure></p><p>好吧好吧，为什么会发生这么奇怪的情况。。。</p><p>其实</p><ul><li>当atime &gt; mtime时，访问文件，文件访问时间不变。</li><li>当atime = mtime时，访问文件，文件访问时间更新。</li></ul><p>Linux文件系统的设计正是这么做的，atime（accesstime）不更新是有一些历史原因的，在2.6内核以前，我们每次访问文件，atime都会更新。后来OS发现更新atime的开销很大，尤其是读频繁的环境。所以后来mount退出了一个noatime的选项，来禁止更新atime，再后来为了兼容atime，又增加了一个兼容的选项relaime，只有在mtime（modify time）大于等于atime（Access time）时，才会更新access time，后来这也成为了很多系统的默认设置。所以，这个访问时间atime有时候并不靠谱。</p><p>程序员思维图，如下</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjhhoi24j30ej0gawf2.jpg" alt="enter description here"></p><p>那我们需要修改文件的时间参数应该怎么做呢？<br>touch命令可以帮到我们，touch命令除了我们常见的创建一堆新文件外，还可以修改时间戳。。。</p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><blockquote><p><code>-a</code>：或–time=atime或–time=access或–time=use 只更改存取时间；<br><code>-c</code>：文件不存在时创建文件，修改文件的三个时间到当前时间<br><code>-d</code>：&lt;时间日期&gt; 使用指定的日期时间，而非现在的时间；<br><code>-f</code>：此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题；<br><code>-m</code>：或–time=mtime或–time=modify 只更该变动时间；<br><code>-r</code>：&lt;参考文件或目录&gt; 把指定文件或目录的日期时间，统统设成和参考文件或目录的日期时间相同；<br><code>-t</code>：&lt;日期时间&gt; 使用指定的日期时间，而非现在的时间；<br><code>--help</code>：在线帮助；<br><code>--version</code>：显示版本信息。</p></blockquote><p>使用方式简单，故不再累述</p><p>参考链接<br><a href="http://blog.csdn.net/LLZK_/article/details/53932580" target="_blank" rel="noopener">http://blog.csdn.net/LLZK_/article/details/53932580</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux_time_params </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>container/list实现</title>
      <link href="/2018/01/23/container_list/"/>
      <url>/2018/01/23/container_list/</url>
      
        <content type="html"><![CDATA[<p>最近看到go源码里的<code>container/list</code>，实现双向循环列表，记录一下关键部分。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><code>循环链表（circular linked list）</code>将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环列表。</li><li><code>双向链表（double linkedlist）</code> 在单链表的每个结点中，再设置一个指向其前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。</li></ul><p>双向循环列表就是二者的结合体，如图为非空的循环的带头结点的双向链表: </p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjby35qyj30w006zq3p.jpg" alt="非空的循环的带头结点的双向链表"></p><p>在线性表中最实用的就是双向循环列表，Go语言中双向循环列表<code>container/list</code>:</p><ul><li>使用方法：<a href="https://golang.org/pkg/container/list/" target="_blank" rel="noopener">Package list</a></li><li>源码: <a href="https://golang.org/src/container/list/list.go" target="_blank" rel="noopener">Source file src/container/list/list.go</a></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="节点结构体"><a href="#节点结构体" class="headerlink" title="节点结构体"></a>节点结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Element is an element of a linked list.</span></span><br><span class="line"><span class="keyword">type</span> Element <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//next and prev node of list </span></span><br><span class="line">next, prev *Element</span><br><span class="line"></span><br><span class="line"><span class="comment">// The list to which this element belongs.</span></span><br><span class="line">list *List</span><br><span class="line"></span><br><span class="line"><span class="comment">// The value stored with this element.</span></span><br><span class="line">Value <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要点：</p><ul><li>类似C语言中的空指针可以指向任何数据结构，空接口可以赋值任何数据结构。</li><li>添加<code>list</code>指针，标识节点属于的<code>list</code>。</li></ul><a id="more"></a><h4 id="列表结构体"><a href="#列表结构体" class="headerlink" title="列表结构体"></a>列表结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List represents a doubly linked list.</span></span><br><span class="line"><span class="comment">// The zero value for List is an empty list ready to use.</span></span><br><span class="line"><span class="keyword">type</span> List <span class="keyword">struct</span> &#123;</span><br><span class="line">root Element <span class="comment">// sentinel list element, only &amp;root, root.prev, and root.next are used</span></span><br><span class="line"><span class="built_in">len</span>  <span class="keyword">int</span>     <span class="comment">// current list length excluding (this) sentinel element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法实现"><a href="#方法实现" class="headerlink" title="方法实现"></a>方法实现</h3><p><code>list</code>中主要实现了第三个主要方法，其他方法依赖于此方法。</p><h4 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h4><p>空循环列表：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjcb4q25j30lc0cqjrz.jpg" alt="空循环列表"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init initializes or clears list l.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">Init</span><span class="params">()</span> *<span class="title">List</span></span> &#123;</span><br><span class="line">    l.root.next = &amp;l.root</span><br><span class="line">    l.root.prev = &amp;l.root</span><br><span class="line">    l.<span class="built_in">len</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="节点插入"><a href="#节点插入" class="headerlink" title="节点插入"></a>节点插入</h4><p>双向链表的插入操作：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjcj9qf8j30lc0ecabv.jpg" alt="双向链表的插入操作"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert inserts e after at, increments l.len, and returns e.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">insert</span><span class="params">(e, at *Element)</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">    n := at.next</span><br><span class="line">    at.next = e</span><br><span class="line">    e.prev = at</span><br><span class="line">    e.next = n</span><br><span class="line">    n.prev = e</span><br><span class="line">    e.list = l</span><br><span class="line">    l.<span class="built_in">len</span>++</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="节点删除"><a href="#节点删除" class="headerlink" title="节点删除"></a>节点删除</h4><p>双向链表的删除操作</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjcqaly1j30w00b9tau.jpg" alt="双向链表的删除操作"><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove removes e from its list, decrements l.len, and returns e.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">remove</span><span class="params">(e *Element)</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line">    e.prev.next = e.next</span><br><span class="line">    e.next.prev = e.prev</span><br><span class="line">    e.next = <span class="literal">nil</span> <span class="comment">// avoid memory leaks</span></span><br><span class="line">    e.prev = <span class="literal">nil</span> <span class="comment">// avoid memory leaks</span></span><br><span class="line">    e.list = <span class="literal">nil</span></span><br><span class="line">    l.<span class="built_in">len</span>--</span><br><span class="line">    <span class="keyword">return</span> e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>双向循环列表的其他操作的函数，基于以上的操作实现。</p><p>通过值得方式插入节点：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insertValue is a convenience wrapper for insert(&amp;Element&#123;Value: v&#125;, at).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *List)</span> <span class="title">insertValue</span><span class="params">(v <span class="keyword">interface</span>&#123;&#125;, at *Element)</span> *<span class="title">Element</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> l.insert(&amp;Element&#123;Value: v&#125;, at)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.zybuluo.com/guoxs/note/229118#61-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%AE%9A%E4%B9%89" target="_blank" rel="noopener">数据结构之线性表</a></p>]]></content>
      
      
      <categories>
          
          <category> Go </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go_source </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python数据结构练习</title>
      <link href="/2018/01/23/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0/"/>
      <url>/2018/01/23/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%83%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>随手记录一些经典实例，以便以后复习</p><h3 id="1-已知字符串-a-“aAsmr3idd4bgs7Dlsf9eAF”-要求如下"><a href="#1-已知字符串-a-“aAsmr3idd4bgs7Dlsf9eAF”-要求如下" class="headerlink" title="1. 已知字符串 a = “aAsmr3idd4bgs7Dlsf9eAF”,要求如下"></a>1. 已知字符串 a = “aAsmr3idd4bgs7Dlsf9eAF”,要求如下</h3><p><strong>1.1 请将a字符串的大写改为小写，小写改为大写。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.swapcase()</span><br></pre></td></tr></table></figure></p><a id="more"></a><p><strong>1.2 请将a字符串的数字取出，并输出成一个新的字符串。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;&apos;join([x for x in a if x.isdigit()]) #&apos;&apos;join以指定的分隔符生成新的字符串</span><br></pre></td></tr></table></figure></p><p><strong>1.3 请统计a字符串出现的每个字母的出现次数（忽略大小写，a与A是同一个字母），并输出成一个字典。 例 {‘a’:4,’b’:2}</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;x : a.count(x) for x in set(a.lower())&#125;</span><br><span class="line">dict&#123;[a,a.count(x) for x in set(a.lower())]&#125;</span><br></pre></td></tr></table></figure></p><p><strong>1.4 请去除a字符串多次出现的字母，仅留最先出现的一个。例 ‘abcabb’，经过去除后，输出 ‘abc’</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;aAsmr3idd4bgs7Dlsf9eAF&quot;</span><br><span class="line">a_list = list(a)                    # 转化为列表，并保存元素顺序</span><br><span class="line">set_list = list(set(a_list))        # 去重</span><br><span class="line">set_list.sort(key=a_list.index)     # 排序传递的是函数</span><br><span class="line">print &apos;&apos;.jion(set_list)             # 以字符串输出</span><br></pre></td></tr></table></figure></p><blockquote><p>tips:<br>sort 与 sorted 区别：<br>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。<br>list 的 sort 方法返回的是对已经存在的列表进行操作(<code>list = [].sort()</code>错误的写法)，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作</p></blockquote><p><strong>1.5 请将a字符串反转并输出。例：’abc’的反转是’cba’</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ①方法一：</span><br><span class="line">a = &quot;abc&quot;</span><br><span class="line">b = list(a)</span><br><span class="line">b.reverse()   # 列表的reverse函数没有返回值，会改变列表本身</span><br><span class="line">a = &apos;&apos;join(b) # 列表转化为字符串</span><br><span class="line"># ②方法二：</span><br><span class="line">print a[::-1]</span><br></pre></td></tr></table></figure></p><p><strong>1.6 去除a字符串内的数字后，请将该字符串里的单词重新排序（a-z），并且重新输出一个排序后的字符串。（保留大小写,a与A的顺序关系为：A在a前面。例：AaBb）</strong><br>思路：<br>①先用sorted方法排序，观察排序结果<br>②把大写字母结果放到a_lower_list = []<br>把小写字母结果放到a_upper_list = []<br>③迭代小写字母a_lower_list[]表，把如果有相同小写字母表的大写写字母加到大写字母表的位置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">a = &quot;aAsmr3idd4bgs7Dlsf9eAF&quot;</span><br><span class="line">a_list = sorted(list(a))</span><br><span class="line">a_lower_list = []</span><br><span class="line">a_upper_list = []</span><br><span class="line"></span><br><span class="line">for x in a :</span><br><span class="line">    if x.islower():</span><br><span class="line">        a_lower_list.append(x)</span><br><span class="line">    if x.isupper():</span><br><span class="line">        a_upper_list.append(x)</span><br><span class="line"></span><br><span class="line">for y in a_upper_list:</span><br><span class="line">    y_lower = y.lower()</span><br><span class="line">    if y_lower in a_lower_list:</span><br><span class="line">        a_lower_list.insert(a_lower_list.index(y_lower),y)</span><br><span class="line">print(a_lower_list)</span><br><span class="line"></span><br><span class="line">for y in a_lower_list:</span><br><span class="line">    if y.upper() in a_upper_list:</span><br><span class="line">        #a_upper = a_upper_list.pop(y.upper())</span><br><span class="line">        a_upper_list.insert(a_upper_list.index(y.upper()),y)</span><br><span class="line">print(a_lower_list)</span><br></pre></td></tr></table></figure></p><p><strong>1.7 请判断 ‘boy’里出现的每一个字母，是否都出现在a字符串里。如果出现，则输出True，否则，则输出False.</strong><br>思路：集合的里面的数是不重复的，当你往集合中加相同的数是，其长度不会改变</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;aAsmr3idd4bgs7Dlsf9eAF&quot;</span><br><span class="line">search = &quot;boy&quot;</span><br><span class="line">u = set(a)</span><br><span class="line">u.update(list(search))</span><br><span class="line">print len(u) == len(set(a))</span><br></pre></td></tr></table></figure><p><strong>1.8 要求如1.7，此时的单词判断，由’boy’改为四个，分别是 ‘boy’,’girl’,’bird’,’dirty’，请判断如上这4个字符串里的每个字母，是否都出现在a字符串里。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = &quot;aAsmr3idd4bgs7Dlsf9eAF&quot;</span><br><span class="line">search = &apos;boy&apos;+&apos;girl&apos;+&apos;bird&apos;+&apos;dirty&apos;</span><br><span class="line">u = set(a)</span><br><span class="line">u.update(list(set(search)))</span><br><span class="line">print len(u) == len(set(a))</span><br></pre></td></tr></table></figure></p><p><strong>1.9 输出a字符串出现频率最高的字母</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l = [(x ,a.count(x)) for x in set(a)]</span><br><span class="line"> sorted(l,key = lambda x :x[1])[-1]</span><br><span class="line">l = [(x ,a.count(x)) for x in set(a)]</span><br><span class="line">l.sort(key = lambda x :x[1])</span><br><span class="line">print l[-1]</span><br></pre></td></tr></table></figure></p><p><strong>2.在python命令行里，输入import this 以后出现的文档，统计该文档中，”be” “is” “than” 的出现次数。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">m = os.popen(&apos;python -m this &apos;).read()  #没有read()之前是一个file对象，之后为字符串对象,可通过type(m)查看</span><br><span class="line">m = m.replace(&apos;&apos;,&apos;\n&apos;)                  #换去字符串末尾的换行符号&apos;\n&apos;</span><br><span class="line">l = m.split(&apos; &apos;)                        #split()通过指定分隔符对字符串进行切片，如果参数num 有指定值，则仅分隔 num 个子字符串 返回指定分隔符字符串列表</span><br><span class="line">print [(x, l.count(x)) for x in [&apos;be&apos;,&apos;is&apos;,&apos;than&apos;]]</span><br></pre></td></tr></table></figure></p><p><strong>3.一文件的字节数为<code>102324123499123</code>，请计算该文件按照kb与mb计算得到的大小。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size = 102324123499123</span><br><span class="line">print( &apos;size: %s KB&apos;%(size&gt;&gt;10))</span><br><span class="line">print( &apos;size: %s MB&apos;%(size&gt;&gt;20))</span><br></pre></td></tr></table></figure></p><blockquote><p>右位移计算：size = size / 2^10<br>左位移计算：size = size * 2^10<br>位移运算对于单位换算较为方便</p></blockquote><p><strong>4.已知  a =  [1,2,3,6,8,9,10,14,17],请将该list转换为字符串，例如 ‘123689101417’.</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> a =  [1,2,3,6,8,9,10,14,17]</span><br><span class="line">print (str(a)[1:-1:3])                 #单个数有效,当每个数是两位数时，有问题</span><br><span class="line">print str(a)[1:-1].replace(&apos;, &apos;,&apos;&apos;)  #有效的方法</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> exercise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python面试题</title>
      <link href="/2018/01/23/python%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/01/23/python%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="说明os-sys模块不同，并列举常用的模块方法"><a href="#说明os-sys模块不同，并列举常用的模块方法" class="headerlink" title="说明os,sys模块不同，并列举常用的模块方法"></a>说明<code>os</code>,<code>sys</code>模块不同，并列举常用的模块方法</h3><p>官方解释：<br><code>os</code> This module provides a portable way of using operating system dependent functionality.<br>翻译：提供一种方便的使用操作系统函数的方法。<br><code>sys</code>This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter.<br>翻译：提供访问由解释器使用或维护的变量和在与解释器交互使用到的函数。<br><a id="more"></a></p><p><code>sys</code> 常用方法</p><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>sys.argv()</td><td>命令行参数List，第一个元素是程序本身路径</td></tr><tr><td>sys.modules.keys()</td><td>返回所有已经导入的模块列表</td></tr><tr><td>sys.exc_info()</td><td>获取当前正在处理的异常类,exc_type、exc_value、exc_traceback当前处理的异常详细信息</td></tr><tr><td>sys.exit(n)</td><td>退出程序，正常退出时exit(0)</td></tr><tr><td>sys.hexversion</td><td>获取Python解释程序的版本值，16进制格式如：0x020403F0</td></tr><tr><td>sys.version</td><td>获取Python解释程序的版本信息</td></tr><tr><td>sys.maxint</td><td>最大的Int值</td></tr><tr><td>sys.maxunicode</td><td>最大的Unicode值</td></tr><tr><td>sys.modules</td><td>返回系统导入的模块字段，key是模块名，value是模块</td></tr><tr><td>sys.path</td><td>返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值</td></tr><tr><td>sys.platform</td><td>返回操作系统平台名称</td></tr><tr><td>sys.stdout</td><td>标准输出</td></tr><tr><td>sys.stdin</td><td>标准输入</td></tr><tr><td>sys.stderr</td><td>错误输出</td></tr><tr><td>sys.exc_clear()</td><td>用来清除当前线程所出现的当前的或最近的错误信息</td></tr><tr><td>sys.exec_prefix</td><td>返回平台独立的python文件安装的位置</td></tr><tr><td>sys.byteorder</td><td>本地字节规则的指示器，big-endian平台的值是’big’,little-endian平台的值是’little’</td></tr><tr><td>sys.copyright</td><td>记录python版权相关的东西</td></tr><tr><td>sys.api_version</td><td>解释器的C的API版本</td></tr><tr><td>sys.getdefaultencoding()</td><td>返回当前你所用的默认的字符编码格式</td></tr><tr><td>sys.getfilesystemencoding()</td><td>返回将Unicode文件名转换成系统文件名的编码的名字</td></tr><tr><td>sys.builtin_module_names</td><td>Python解释器导入的模块列表</td></tr><tr><td>sys.executable</td><td>Python解释程序路径</td></tr><tr><td>sys.getwindowsversion()</td><td>获取Windows的版本</td></tr><tr><td>sys.stdin.readline()</td><td>从标准输入读一行，sys.stdout.write(“a”) 屏幕输出a</td></tr></tbody></table><p><code>OS</code> 常用方法</p><table><thead><tr><th>方法</th><th>使用</th></tr></thead><tbody><tr><td>os.remove()</td><td>删除文件</td></tr><tr><td>os.rename()</td><td>重命名文件</td></tr><tr><td>os.walk()</td><td>生成目录树下的所有文件名</td></tr><tr><td>os.chdir()</td><td>改变目录</td></tr><tr><td>os.mkdir/makedirs</td><td>创建目录/多层目录</td></tr><tr><td>os.rmdir/removedirs</td><td>删除目录/多层目录</td></tr><tr><td>os.listdir()</td><td>列出指定目录的文件</td></tr><tr><td>os.getcwd()</td><td>取得当前工作目录</td></tr><tr><td>os.chmod()</td><td>改变目录权限</td></tr><tr><td>os.path.basename()</td><td>去掉目录路径，返回文件名</td></tr><tr><td>os.path.dirname()</td><td>去掉文件名，返回目录路径</td></tr><tr><td>os.path.join()</td><td>将分离的各部分组合成一个路径名</td></tr><tr><td>os.path.split()</td><td>返回（dirname(),basename())元组</td></tr><tr><td>os.path.splitext()</td><td>(返回filename,extension)元组</td></tr><tr><td>os.path.getatime\ctime\mtime</td><td>分别返回最近访问、创建、修改时间</td></tr><tr><td>os.path.getsize()</td><td>返回文件大小</td></tr><tr><td>os.path.exists()</td><td>是否存在</td></tr><tr><td>os.path.isabs()</td><td>是否为绝对路径</td></tr><tr><td>os.path.isdir()</td><td>是否为目录</td></tr><tr><td>os.path.isfile()</td><td>是否为文件</td></tr></tbody></table><h3 id="解释类方法、静态方法"><a href="#解释类方法、静态方法" class="headerlink" title="解释类方法、静态方法"></a>解释类方法、静态方法</h3><blockquote><p>@classmethod means: when this method is called, we pass the class as the first argument instead of the instance of that class (as we normally do with methods). This means you can use the class and its properties inside that method rather than a particular instance.<br><!--more--><br>类方法：当类方法被调用时，我们用类作为第一个参数作为参数传递（一般方法通过对象），换句话说你可以通过类使用类的属性和方法，而不是通过一个特别的对象</p></blockquote><blockquote><p>@staticmethod means: when this method is called, we don’t pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can’t access the instance of that class (this is useful when your method does not use the instance).</p></blockquote><p>静态方法：当静态方法被调用时，不是通过像一个普通的类方法一样用过类的实例去调用方法，换句话说，你把一个函数放到类中，但是你不能通过该静态函数去访问类的对象（当你的方法不使用对象时有用）=&gt;保证了数据安全</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">class Animal(object):</span><br><span class="line">    def foo(self,x):</span><br><span class="line">        print(self,x)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_foo(x):</span><br><span class="line">        print(x)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def class_foo(cls,x):</span><br><span class="line">        print(cls,x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = Animal()</span><br><span class="line">a.foo(1)             # 调用一般方法</span><br><span class="line">Animal.static_foo(1) # 调用静态方法</span><br><span class="line">Animal.class_foo(1)  # 调用类方法</span><br></pre></td></tr></table></figure><h3 id="书写一个函数，用于替换某个字符串或几个字符串"><a href="#书写一个函数，用于替换某个字符串或几个字符串" class="headerlink" title="书写一个函数，用于替换某个字符串或几个字符串"></a>书写一个函数，用于替换某个字符串或几个字符串</h3><p>函数原型strreplace（str，oldString，newString）<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;s = &apos;Hello World!&apos;;</span><br><span class="line">&gt;&gt;afterReplace = strreplace(s,&apos;World&apos;,&apos;Tom&apos;)</span><br><span class="line">输出结果为：&quot;Hello Tom!&quot;</span><br></pre></td></tr></table></figure></p><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def strreplace(str，oldString，newString):</span><br><span class="line">  str_list = str.split(oldString)</span><br><span class="line">    print(newString.join(str_list))</span><br><span class="line"></span><br><span class="line">strrepalce(&apos;Hello World !&apos;,&apos;World&apos;,&apos;Tom&apos;)</span><br></pre></td></tr></table></figure></p><h3 id="遍历查找指定后缀文件"><a href="#遍历查找指定后缀文件" class="headerlink" title="遍历查找指定后缀文件"></a>遍历查找指定后缀文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line"># 1. for-in dir/subdir to get the filesname</span><br><span class="line"># 2. splitext filename to filter</span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">def getFiles(dir, suffix): # 查找根目录，文件后缀 </span><br><span class="line">    res = []</span><br><span class="line">    for root, directory, files in os.walk(dir):  # =&gt;当前根,根下目录,目录下的文件</span><br><span class="line">        for filename in files:</span><br><span class="line">            name, suf = os.path.splitext(filename) # =&gt;文件名,文件后缀</span><br><span class="line">            if suf == suffix:</span><br><span class="line">                res.append(os.path.join(root, filename)) # =&gt;吧一串字符串组合成路径</span><br><span class="line">    return res</span><br><span class="line"></span><br><span class="line">for file in getFiles(&quot;./&quot;, &apos;.py&apos;):# =&gt;查找以.py结尾的文件</span><br><span class="line">    print(file)</span><br></pre></td></tr></table></figure><h3 id="实现删除一个list里面的重复元素-元素顺序并不改变）"><a href="#实现删除一个list里面的重复元素-元素顺序并不改变）" class="headerlink" title="实现删除一个list里面的重复元素(元素顺序并不改变）"></a>实现删除一个list里面的重复元素(元素顺序并不改变）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">a = &quot;aAsmr3idd4bgs7Dlsf9eAF&quot;</span><br><span class="line">a_list = list(a)  # 转化为列表，并保存元素顺序</span><br><span class="line">set_list = list(set(a_list))  # 去重</span><br><span class="line">set_list.sort(key=a_list.index)</span><br><span class="line">s = &apos;&apos;.join(set_list)</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure><h3 id="实现分组一个-list-里面的元素-比如-1-2-3-100-变成-1-2-3-4-5-6"><a href="#实现分组一个-list-里面的元素-比如-1-2-3-100-变成-1-2-3-4-5-6" class="headerlink" title="实现分组一个 list 里面的元素,比如 [1,2,3,...100]变成 [[1,2,3],[4,5,6]....]"></a>实现分组一个 list 里面的元素,比如 <code>[1,2,3,...100]</code>变成 <code>[[1,2,3]</code>,<code>[4,5,6]....]</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">list = []</span><br><span class="line">list_temp =[]</span><br><span class="line">for l in (x for x in range(1,101)):</span><br><span class="line">    list_temp.append(l)</span><br><span class="line">    if len(list_temp)==3:</span><br><span class="line">        list.append(list_temp)</span><br><span class="line">        del list_temp</span><br><span class="line">        list_temp = []</span><br><span class="line">print(list)</span><br></pre></td></tr></table></figure><h3 id="写出一个函数-给定参数-n-生成含有-n-个元素值为-1-n-的数-组-元素顺序随机-但值不重复"><a href="#写出一个函数-给定参数-n-生成含有-n-个元素值为-1-n-的数-组-元素顺序随机-但值不重复" class="headerlink" title="写出一个函数,给定参数 n,生成含有 n 个元素值为 1~n 的数 组,元素顺序随机,但值不重复"></a>写出一个函数,给定参数 n,生成含有 n 个元素值为 1~n 的数 组,元素顺序随机,但值不重复</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line">def random_list(n):</span><br><span class="line">    list =random.sample(range(1,n+1),n)</span><br><span class="line">    return list</span><br><span class="line"></span><br><span class="line">print(random_list(6))</span><br></pre></td></tr></table></figure><h3 id="在不用其他变量的情况下，交换a、b变量的值"><a href="#在不用其他变量的情况下，交换a、b变量的值" class="headerlink" title="在不用其他变量的情况下，交换a、b变量的值"></a>在不用其他变量的情况下，交换a、b变量的值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># pyhton</span><br><span class="line">a,b = b,a</span><br><span class="line"></span><br><span class="line"># 其他语言</span><br><span class="line">a = a + b</span><br><span class="line">b = a - b</span><br><span class="line">a = a - b</span><br></pre></td></tr></table></figure><h3 id="写出下面代码的输出结果"><a href="#写出下面代码的输出结果" class="headerlink" title="写出下面代码的输出结果"></a>写出下面代码的输出结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line"></span><br><span class="line">def extend_list(val,list = []):</span><br><span class="line">    list.append(val)</span><br><span class="line">    return list</span><br><span class="line"></span><br><span class="line">list1 = extend_list(10)</span><br><span class="line">list2 = extend_list(123, [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])</span><br><span class="line">list3 = extend_list(&apos;a&apos;)</span><br><span class="line"></span><br><span class="line">print(&apos;list1:&apos;,list1)</span><br><span class="line">print(&apos;list2:&apos;,list2)</span><br><span class="line">print(&apos;list3:&apos;,list3)</span><br><span class="line"></span><br><span class="line">print(hex(id(list1)))</span><br><span class="line">print(hex(id(list2)))</span><br><span class="line">print(hex(id(list3)))</span><br></pre></td></tr></table></figure><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1: [10, &apos;a&apos;]</span><br><span class="line">list2: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, 123]</span><br><span class="line">list3: [10, &apos;a&apos;]</span><br><span class="line">0x17356fb8648   #</span><br><span class="line">0x17356fb8d08</span><br><span class="line">0x17356fb8648   #list1和list2 内存地址相同</span><br></pre></td></tr></table></figure></p><h3 id="用python魔法方法实现以下案例"><a href="#用python魔法方法实现以下案例" class="headerlink" title="用python魔法方法实现以下案例"></a>用python魔法方法实现以下案例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用python的魔法方法实现</span><br><span class="line">class Foo</span><br><span class="line">print(Foo().think.different.incast)</span><br><span class="line"></span><br><span class="line">输出结果：</span><br><span class="line">think different itcast</span><br></pre></td></tr></table></figure><p>代码实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    &apos;&apos;&apos; &apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    def __getattr__(self, item):  # 属性拦截器</span><br><span class="line">        print(item, end=&apos; &apos;)  # 不换行输出</span><br><span class="line">        return self</span><br><span class="line"></span><br><span class="line">    def __str__(self):  # 调用对象</span><br><span class="line">        return &apos;&apos;</span><br><span class="line"></span><br><span class="line">    # def __getattribute__(self, item): # 定义当通过点（.）去调用属性时，查找的次序</span><br><span class="line">    #     pass</span><br><span class="line"></span><br><span class="line">print(Foo().think.different.incast)</span><br></pre></td></tr></table></figure></p><blockquote><p>注释，当对访问属性时，会先查询python类的内内建方法<code>__dic__</code>中去查找，当没有找到时，就会去调用python 内建方法<code>__getattr__</code> （属性拦截器）,调用它来看看是否有调用属性值之前的操作。跟其相似的方法<code>__getattribute__</code>就是定义了调用类属性时，查找的次序，一般不做修改。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RIAD工作原理</title>
      <link href="/2018/01/23/raid/"/>
      <url>/2018/01/23/raid/</url>
      
        <content type="html"><![CDATA[<p>Raid旧称Redundant Array of Inexpensive Disks，即廉价磁盘冗余阵列；现称Redundant Array of Independent Disks，即独立磁盘冗余阵列，简称为磁盘阵列。其基本的思想是把多个相对廉价的磁盘进行组合成为一个磁盘阵列组，以达到甚至超越一个价格相对昂贵，容量相对大的磁盘。根据Raid版本的不同，Raid相对于散列的磁盘可以提供多方面的优势：更强的容错功能、更快的读写速度、更高的资料整合度等等……</p><p>简单来说，Raid的效果是把多个磁盘组成一个逻辑区域，因此系统只会将其视作一块磁盘。以往，Raid主要出现在服务器领域，而随着技术的不断发展，Raid也逐渐进入了玩家的世界。<br><a id="more"></a></p><h3 id="Raid实现"><a href="#Raid实现" class="headerlink" title="Raid实现"></a>Raid实现</h3><ul><li><p>纯软件Raid ：指程序运行在操作系统中且没有其他额外硬件参与的Raid模式。在这种模式下磁盘通常直接连接至计算机的I/O接口或是没有经过处理器的HBA。这样只有在操作系统加载了Raid驱动软件之后，整个阵列才会变成活动对象。这样的Raid模式通常被当作操作系统的一项额外附加值赠送给用户，其最大的特色就是低廉的成本。</p></li><li><p>半软件半硬件Raid：指通过一些硬件帮助Raid软件完成其薄弱环节的模式。在这种模式下通常会有一些额外的硬件参与其中（比如带有Raid BIOS的HBA或直接在主板上加入Raid BIOS芯片等）。这颗额外的BIOS可以使得系统通电后阵列就能成为活动对象，在启动的过程中提供冗余。除此以外，大多数的类似方案还提供一个BIOS软件使得维护阵列可以不用启动操作系统。而且，这种硬件辅助的Raid通常都拥有跨平台的驱动，因此其相比于纯软件Raid更不依赖于操作系统。<br>.</p></li><li>纯硬件Raid：指一张独立的Raid卡或者基于RoC（Raid on Chip）技术的硬件方案。Raid卡通常内置了Raid处理器（I/O）处理器并且拥有自己的驱动接口（I/O控制器）。比较常见的是通过主板上的PCI或者PCI-e接口与系统进行连接。Raid卡通常是非常昂贵的，但也是最灵活和高效的解决方案。在这种情况下Raid的运行是完全独立于操作系统的。这样Raid处理器将可以提供最好的磁盘性能并且完全释放计算机硬件的负担。在RoC方案中，Raid控制器，缓存控制器，I/O面板甚至缓存都被聚集在一块芯片上。这样的芯片可以是整体安装在主板上或者安装在一块独立的PCB上，其中最常见于服务器主板上。</li></ul><h2 id="Raid版本"><a href="#Raid版本" class="headerlink" title="Raid版本"></a>Raid版本</h2><h3 id="Raid-0"><a href="#Raid-0" class="headerlink" title="Raid 0"></a>Raid 0</h3><p>Raid 0是将多个磁盘直接合并成一个大的磁盘，并行I/O，没有冗余。在存放数据的时候，控制器将数据按照磁盘个数进行分段，并同时将这些分段写入相对应的磁盘之中。这样做的好处是Raid 0在所有的阵列之中拥有最快的读写速率，然而由于Raid 0并不具有冗余功能，只要有任意一块磁盘发生损坏，那么所有磁盘上的数据都会丢失。理论上Raid 0的效能就是单磁盘效能与磁盘数的乘积，但受制于I/O瓶颈以及环境影响，其实际效能也会遵从边际效应。也就是说，随着磁盘数的增加，带来的效能提升会逐渐减小。其工作原理如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjxz6dcej30tv0jdn26.jpg" alt="enter description here"></p><h3 id="Raid-1"><a href="#Raid-1" class="headerlink" title="Raid 1"></a>Raid 1</h3><p>Raid 1是将多个磁盘进行互相镜像。在数据写入的时候，控制器将数据同时写入所有磁盘，因此只有在所有的磁盘都发生损坏的情况下才会丢失数据。另外，由于所有的磁盘中都写有相同的数据，因此在读取数据的时候可以通过多线程达到很好的读取速度。当主磁盘发生损坏时，镜像磁盘可以直接代替主磁盘继续工作，故Raid 1拥有所有Raid中最好的安全性。但是无论用多少磁盘组建Raid 1，都只有一块磁盘的容量，且实际可用空间是所有磁盘中容量最小的尺寸，因此Raid 1也是所有Raid中磁盘利用率最低的一个级别。其工作原理如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjy6xqvrj30kw0cvgm9.jpg" alt="enter description here"></p><h3 id="Raid-2"><a href="#Raid-2" class="headerlink" title="Raid 2"></a>Raid 2</h3><p>Raid 2是Raid 0的改良版，在Raid 0的基础上增加了基于Hamming Code的错误修正码（ECC，Error Correction Code）。磁盘组中序号为2的幂的磁盘（第1个、第2个、第4个、第8个……）为校验盘，用于存储校验信息。从这个特征中我们很容易就可以得到一个结论：阵列中的磁盘总数越多，校验磁盘所占的比例越低，磁盘空间利用率越高。组建Raid 2需要至少3个磁盘，其工作原理如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjyeyi8oj30np0e6408.jpg" alt="enter description here"></p><h3 id="Raid-3"><a href="#Raid-3" class="headerlink" title="Raid 3"></a>Raid 3</h3><p>Raid 3与Raid 2非常类似，其区别在于完全使用一个磁盘存储校验信息，实际可用容量是所有磁盘容量的总和减去一块磁盘。这样做的好处是，当某块数据磁盘发生损坏时，可以通过其他数据磁盘和校验磁盘算出损失的数据；而当校验磁盘发生损坏时，数据磁盘也依旧可以进行工作并可以重新生成校验数据。而Raid 3的性能主要由容错算法和分块大小所决定。组建Raid 3至少需要3块磁盘，其工作原理如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjyqjntej30my0e5myj.jpg" alt="enter description here"></p><h3 id="Raid-4"><a href="#Raid-4" class="headerlink" title="Raid 4"></a>Raid 4</h3><p>Raid 4是一种思路与Raid 3非常相似的方案。其与Raid 3的不同就在于，Raid 4是将数据按区块为单位进行分割的，每次的数据读写过程中都必须从校验磁盘中取出相应的校验进行核对，这样可能带来的隐患是，校验磁盘会由于过度频繁的使用导致损耗率提高。Raid 4的工作原理如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjzdneeej30m50e0mym.jpg" alt="enter description here"></p><h3 id="Raid-5"><a href="#Raid-5" class="headerlink" title="Raid 5"></a>Raid 5</h3><p>Raid 5是一种兼顾存储效能、安全性以及利用率的存储方案，主要是建立在Disk Striping技术上实现的。Raid 5在存储时把数据和相应的奇偶校验信息存储到Raid 5的各个磁盘上，并且把奇偶校验信息和数据分别存于不同的磁盘上。这样当Raid 5中发生一个磁盘损坏的时候，可以利用剩下的磁盘和奇偶校验数据计算恢复损坏的数据。Raid 5可以理解成Raid 0和Raid 1的折中方案，Raid 5提供了接近Raid 0的磁盘读取性能且比Raid 0更高的安全保障。然而由于Raid 5中数据都拥有校验信息，当更改数据时校验会严重影响磁盘的写入性能。Raid 5的写入过程非常繁杂：当新数据进入时，控制器会先读取需要更新扇区上的数据，读出校验数据，写入新数据，写入新校验数据。也就是说，写入新数据这一步需要通过4个动作完成。这个问题通过Raid控制器的缓存可以得到有效改善。其工作原理如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjzmpm16j30p70ecgnj.jpg" alt="enter description here"></p><h3 id="Raid-6"><a href="#Raid-6" class="headerlink" title="Raid 6"></a>Raid 6</h3><p>Raid 6是一种与Raid 5思路非常相似的方案。其与Raid 5的不同点在于，Raid 6增加了第二个独立的效验盘，两个独立的奇偶校验使用不同的算法，相比Raid 5而言进一步提高了数据安全性，允许最多两块磁盘同时发生损坏。然而相比于Raid 5，其缺点也是非常明显的：由于多了一个独立的奇偶校验，磁盘利用率相比Raid 5更低；且两种不同的校验算法同时存在导致磁盘的写入性能进一步降低，这也是其极少被实际应用的原因。建立Raid 6需要至少4个磁盘，Raid 6的工作原理如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjzuonetj30oh0ck75q.jpg" alt="enter description here"></p><h3 id="Raid-10"><a href="#Raid-10" class="headerlink" title="Raid 10"></a>Raid 10</h3><p>Raid 10，亦称Raid 1+0，是将所有的磁盘分成两组，每组先进行Raid 1阵列，然后将两个Raid 1阵列再进行Raid 0阵列。其工作原理如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk01vovtj30vw0ea3zt.jpg" alt="enter description here"></p><h3 id="Raid-01"><a href="#Raid-01" class="headerlink" title="Raid 01"></a>Raid 01</h3><p>Raid 01，亦称Raid 0+1，与Raid 10恰恰相反，是将每组磁盘先进行Raid 0阵列再进行Raid 1阵列。由于Raid 10相较于其有更好的安全性和适用性，通常主板只会支持Raid 10而不支持Raid 01。Raid 01的工作原理如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk086oq3j30wo0eq0uc.jpg" alt="enter description here"></p><h3 id="Raid-50"><a href="#Raid-50" class="headerlink" title="Raid 50"></a>Raid 50</h3><p>Raid 50，亦称Raid 5+0，类似于Raid 10和Raid 01，是将磁盘分为几组，每组磁盘先进行Raid 5阵列，再进行Raid 0阵列。这样做的目的在于提高Raid 5的写入性能。Raid 50的工作原理如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk0i5aigj30vd0bmt9j.jpg" alt="enter description here"></p><p>常见Raid的一些主要信息对比：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk0ozzg9j30yb042jvr.jpg" alt="enter description here"><br> RAID的选择</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk0wt6o2j30g30c7aat.jpg" alt="enter description here"></p>]]></content>
      
      
      <categories>
          
          <category> Linux Service </category>
          
      </categories>
      
      
        <tags>
            
            <tag> raid </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zabbix</title>
      <link href="/2018/01/02/zabbix/"/>
      <url>/2018/01/02/zabbix/</url>
      
        <content type="html"><![CDATA[<h3 id="监控系统的发展"><a href="#监控系统的发展" class="headerlink" title="监控系统的发展"></a>监控系统的发展</h3><p>介绍zabbix之前，先了解一下监控的发展过程：<br>在随着业务量的增长，数据量不断增加，单台服务器不能满足我们的需求，计算机集群出现无疑是解决问题的有效手段，但是这么多服务器怎么去发现故障机，也是比较头疼的问题。于是监控出现了， 厂家也纷纷提供了接口对服务器的健康状态进行监控（其实也就是传感器收集底层数据），但是每个厂家也都有不同接口风格，怎么办？答案是必然的：统一遵循计算机协议，这个协议就是<code>SNMP</code>。<br><a id="more"></a><br>让我们先来熟悉一下什么是snmp<br>SNMP：Simple Network Management Protoclol<br>如名字一样SNMP简单到不能满足需求，其定义如下：</p><blockquote><p>为不同种类的设备、不同厂家生产的设备、不同型号的设备，定义为一个统一的接口和协议，使得管理员可以是使用统一的外观面对这些需要管理的网络设备进行管理。通过网络，管理员可以管理位于不同物理空间的设备，从而大大提高网络管理的效率，简化网络管理员的工作。</p></blockquote><p> SNMP的工作模式是啥？</p><ul><li>NMS向agent采集数据</li><li>agent向NMS报告数据</li><li>NMS请求agent修改配置</li></ul><p>但由于其SNMP的简单性，SNMP同时可以监交换机路由设备，在Internet时代得到了蓬勃的发展，1992年发布了SNMPv2版本，以增强SNMPv1的安全性和功能。现在，已经有了SNMPv3版本。</p><h3 id="我们需要的监控是怎们样的呢？"><a href="#我们需要的监控是怎们样的呢？" class="headerlink" title="我们需要的监控是怎们样的呢？"></a>我们需要的监控是怎们样的呢？</h3><p>设想，身处大数据时代，我们需要监控流程也许是这样的：<br><code>数据采集(数据超过阈值报警)</code>–&gt;<code>数据存储（存储时间序列数据形成实施监控曲线图）</code>–&gt;<code>数据可视化</code></p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk57k52ej30ox0i3jzq.jpg" alt="enter description here"><br>这样看来监控不是一个简单的协议所能实现的了…</p><h3 id="开源工具的尝试"><a href="#开源工具的尝试" class="headerlink" title="开源工具的尝试"></a>开源工具的尝试</h3><h4 id="cacti"><a href="#cacti" class="headerlink" title="cacti"></a>cacti</h4><blockquote><p>一个开源的免费数据收集软件，它的主要功能是用snmp服务获取数据，然后对数据进行储存和更新数据，当用户需要查看数据的时候用生成图表呈现给用户。<br><strong>优点</strong>：实时监控数据变化，以web页面的方式呈现，更直观。<br><strong>缺点</strong>：告警不及时</p></blockquote><h4 id="Nagios"><a href="#Nagios" class="headerlink" title="Nagios"></a>Nagios</h4><blockquote><p>一款开源的免费网络监视工具，能有效监控Windows、Linux和Unix的主机状态，交换机路由器等网络设置，打印机等。在系统或服务状态异常时发出邮件或短信报警第一时间通知网站运维人员，在状态恢复后发出正常的邮件或短信通知。<br><strong>优点</strong>：告警反映迅速。<br><strong>缺点</strong>：监控主机数量有限，承载低</p></blockquote><blockquote><p><strong>为什么不两个软件一起用不就解决问题了吗？</strong><br>是的，早期企业就是这么做的~<br><strong>为什么两个软件不做成一个呢？</strong><br>或许就是zabbix出现的原因</p></blockquote><h4 id="zabbix"><a href="#zabbix" class="headerlink" title="zabbix"></a>zabbix</h4><blockquote><p><code>zabbix</code>  =   <code>cacti</code>   +  <code>nagios</code><br>或许我们可以做一个简单的加法，但是zabbix比你想象的更强大</p><ul><li>zabbix（音同 zæbix）是一个基于WEB界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案<ul><li>zabbix能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。</li><li>zabbix server可以通过SNMP，zabbix-agent，ping，端口监视等方法提供对远程服务器/网络状态的监视，数据收集等功能，它可以运行在Linux，Solaris，HP-UX，AIX，Free BSD，Open BSD，OS X等平台上。</li></ul></li></ul></blockquote><h3 id="zabbix监控功能的实现"><a href="#zabbix监控功能的实现" class="headerlink" title="zabbix监控功能的实现"></a>zabbix监控功能的实现</h3><h4 id="可监控对象"><a href="#可监控对象" class="headerlink" title="可监控对象"></a>可监控对象</h4><blockquote><ul><li><p><strong>设备</strong>：服务器，路由器，交换机</p></li><li><p><strong>软件</strong>：OS，网络，应用程序</p></li><li><p><strong>主机性能指标监控</strong></p></li><li><p><strong>故障监控</strong>： down机，服务不可用，主机不可达</p></li><li><p><strong>IPMI</strong>（Intelligent Platform Management Interface）<br>智慧平台管理接口(原本是一种Intel架构的企业系统的周边设备所采用的一种工业标准。IPMI亦是一个开放的免费标准，使用者无需支付额外的费用即可使用此标准。)</p></li></ul></blockquote><h4 id="支持数据库存储类型"><a href="#支持数据库存储类型" class="headerlink" title="支持数据库存储类型"></a>支持数据库存储类型</h4><blockquote><p><code>abbix-database</code>: MySQL, PGSQL(postgreSQL)、Oracle、DB2、SQLite</p></blockquote><h4 id="Zabbix架构中的组件："><a href="#Zabbix架构中的组件：" class="headerlink" title="Zabbix架构中的组件："></a>Zabbix架构中的组件：</h4><blockquote><p><code>zabbix-server</code>: zabbix服务器端主程序，C语言研发<br><code>zabbix-agent</code>: zabbix客户端端主程序，C语言研发<br><code>zabbix-web</code>：GUI，用于实现zabbix设定和展示,PHP开发<br><code>zabbix-proxy</code>: 分布式监控环境中的专用组件</p></blockquote><p> zabbix设备架构图</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk5ep4hwj30qg0hon3y.jpg" alt="zabbix设备架构"></p><p>逻辑设备架构图</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk5mrnxgj30lp0dv780.jpg" alt="zabbix逻辑设备架构"></p><h3 id="Zabbix逻辑架构"><a href="#Zabbix逻辑架构" class="headerlink" title="Zabbix逻辑架构"></a>Zabbix逻辑架构</h3><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk5szg1fj30zo0mrti3.jpg" alt="工作流程图"></p><blockquote><p>图中没标明<code>template</code>：<code>template</code>模板包括多个<code>items`</code>trigger<code></code>graphs<code>可以直接套用给</code>host<code>或者</code>hostgroups`使用。</p></blockquote><h3 id="Zabbix-Server进程"><a href="#Zabbix-Server进程" class="headerlink" title="Zabbix Server进程"></a>Zabbix Server进程</h3><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk5zuzzuj30mi09u0xz.jpg" alt="zabbix进程及其作用"></p><p>参考：<br><a href="http://www.178linux.com/14454#" target="_blank" rel="noopener">推荐-zabbix原理篇（1）</a><br><a href="https://baike.baidu.com/item/Zabbix" target="_blank" rel="noopener">zabbix百度百科</a><br><a href="http://freeloda.blog.51cto.com/2033581/1306743" target="_blank" rel="noopener">SNMP 原理与实战详解</a></p>]]></content>
      
      
      <categories>
          
          <category> Monitor </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zabbix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux文本处理三剑客之sed</title>
      <link href="/2017/12/23/sed%20using/"/>
      <url>/2017/12/23/sed%20using/</url>
      
        <content type="html"><![CDATA[<h2 id="sed简介"><a href="#sed简介" class="headerlink" title="sed简介"></a>sed简介</h2><p>sed全称Stream Editor，顾名思义为流编辑器，也习惯叫行编辑器，处理文本的方式为按行至上而下读取，匹配，处理并显示或者做其它处理，直到文件末尾。其原理图如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk4cxllqj30ps0d7jsq.jpg" alt="sed工作原理图"></p><a id="more"></a><blockquote><p>命令运行会在内存开辟模式空间和保持空间2个空间用来处理文本内容,流程如下：</p><ol><li>读取文本第一行内容至模式空间</li><li>当内容没有匹配时，默认会输出，当有匹配时则进行编辑操作（修改，替换，删除，追加，显示等）</li><li>处理第一行后,将内容输出，再对第二行处理直到文本结束</li></ol></blockquote><h2 id="模式空间和保存空间"><a href="#模式空间和保存空间" class="headerlink" title="模式空间和保存空间"></a>模式空间和保存空间</h2><p>默认情况下，sed是将输入内容一行一行进行处理的，如下例子</p><blockquote><p>sed ‘1,$p’ /etc/passwd</p></blockquote><p>处理过程：sed会一行一行的读入/etc/passwd文件，查看每行是否匹配定址条件（1,$），如果条件匹配，就将行内容放入模式空间，并打印（p命令）。由于文本流本身的输出，而模式空间内容又被打印一遍，所以这个命令最后会将每一行都显示2遍，默认情况下，sed程序在所有的脚本指令执行完毕后，将自动打印模式空间中的内容，这会导致p命令输出相关行两遍，-n选项可以屏蔽自动打印。    </p><h3 id="模式空间（pattern-space）"><a href="#模式空间（pattern-space）" class="headerlink" title="模式空间（pattern space）"></a>模式空间（pattern space）</h3><p>用于缓存要处理的内容，是sed处理最核心的缓存空间，所有要处理的行内容都会复制进这个空间再进行修改，或根据需要显示。<code>默认sed不会修改原文件本身内容，只修改模式空间内容。</code></p><h3 id="保持空间（hold-space）"><a href="#保持空间（hold-space）" class="headerlink" title="保持空间（hold space）"></a>保持空间（hold space）</h3><p>除了模式空间以外，sed还实现了另一个内容缓存空间，叫保持空间。可以理解这个空间跟模式空间一样，也就是一段内存空间，一般情况下不用，使用相关参数进行使用。</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>sed [OPTION] &#39;script&#39; FILE...</code><br>script中有变量引用时用双引号</p><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><blockquote><p><code>-n</code>: 不输出模式空间中的内容<br><code>-r</code>: 使用扩展正则表达式<br><code>-e</code>: 可以使用多个命令脚本进行操作<br><code>-f sed_script</code>: 从指定的文本中读取处理脚本<br><code>-i</code>: 直接编辑原文件，默认不对原文件进行操</p></blockquote><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>script由<code>地址定界</code>和<code>编辑命令</code>组成，二者间不能有空格，如：’2,5d’<br><code>tips</code>：可能还含有模式匹配/part/g等 修饰符,如以下例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 去除文本中的html标签</span><br><span class="line">echo &quot;This &lt;b&gt; is &lt;/b&gt; an &lt;i&gt;example&lt;/i&gt;.&quot; | sed -e &apos;s/&lt;[^&gt;]*&gt;//g&apos;  #g属于修饰符</span><br></pre></td></tr></table></figure></p><p><strong>地址定界</strong></p><blockquote><ol><li><code>空地址</code>：全文<br>  <code>m</code>：指定第m行<br>  <code>$</code>：最后一行<br> <code>/pattern/</code>：被此模式匹配到的每一行</li><li><code>m,n</code>：从第m行到n行<br>  <code>m,+n</code>：从第m行到m+n行<br> <code>m,/pattern/</code>：从第m行到第一次模式匹配到的行<br> <code>/pat1/,/pat2/</code>：第一次被模式1匹配的行到第一次被模式2匹配到的行</li><li><code>1~2</code>：奇数行<br><code>2~2</code>：偶数行</li></ol></blockquote><p><strong>编辑命令</strong><br>对地址定界下匹配到的内容执行的操作</p><blockquote><p><code>d</code>：删除匹配到的行<br><code>p</code>：打印模式空间中的内容</p><blockquote><p>tips：默认情况下是把“模式空间”中的内容全部进行显示，所以其显示的结果是“默认的显示内容+p的内容”，即匹配的行显示2次，通常与-n选项一起使用，表示只显示匹配到的行</p></blockquote><p><code>a \text</code>：append,在匹配到的行之后追加text，支持\n实现多行插入<br><code>i \text</code>：insert,在匹配到的行之前追加text<br><code>c \text</code>：change,把匹配到的行和给定的文本进行交换<br><code>w file</code>：将匹配到的内容另存到指定的文件中<br><code>r file</code>：将读取指定的文件内容到匹配的行处（如果指定文件为多行时，追加到匹配行之后）<br><code>=</code>：为匹配到的行在上一行添加行号 ，如sed ‘=’ /etc/fstab<br><code>!</code>：条件取反，格式为地址定界！编辑命令，如’5!d’表第5行不删<br><code>s/pattern/str/[修饰符]</code>：查找替换，常用s@@@和s###</p><blockquote><p>[修饰符]：<br><code>g</code>全局，默认只匹配每一行的第一个<br><code>i</code>不区分大小写<br><code>p</code>显示替换成功的行<br><code>后向引用</code>：<code>\(**\)</code>，<code>\1，\2...</code>对应括号内容<br><code>&amp;</code>表示引用匹配到整个文本</p></blockquote><p><code>y/inchars/outchars/</code>：全局转换命令，会进行inchars和outchars的一对一转换</p></blockquote><p><strong>实例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 打印第二行到第一次以#开头的行  </span><br><span class="line">sed -n &apos;2,/^#/p&apos; /tmp/file1  </span><br><span class="line"></span><br><span class="line"># 去除文本中的html标签</span><br><span class="line">echo &quot;This &lt;b&gt; is &lt;/b&gt; an &lt;i&gt;example&lt;/i&gt;.&quot; | sed -e &apos;s/&lt;[^&gt;]*&gt;//g&apos;  </span><br><span class="line"></span><br><span class="line"># 全文每行后添加2行内容  </span><br><span class="line">sed &apos;a \new line\another&apos; /tmp/file2  </span><br><span class="line"></span><br><span class="line"># 删除文件中的空白行</span><br><span class="line">sed -r &apos;/^[[:space:]]*$/d&apos; file3  </span><br><span class="line"></span><br><span class="line"># file4中第一次以#开头的行到第一次以ID结尾的行写入sed.txt中    </span><br><span class="line">sed -n &apos;/^#/,/ID$/w sed.txt&apos; file4  </span><br><span class="line"></span><br><span class="line"># 取基名，包括有无最后‘/’的情况  </span><br><span class="line">echo &quot;/etc/rc.d/&quot; | sed -r &apos;s@^/.*/([^/]+)/?@\1@g&apos;  </span><br><span class="line"></span><br><span class="line"># 取目录名，（将基名删除）</span><br><span class="line">echo &apos;/etc/rc.d/init.d/function&apos; | sed -r &apos;s@[^/]+/?$@@&apos;</span><br></pre></td></tr></table></figure></p><h3 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a>高级命令</h3><p>所谓的高级就是用上图示中的保持空间的功能，可以实现模式空间与保持空间中的内容互相替换，追加，删除等操作，以得到各种匪夷所思的结果，强大到没朋友…真正熟练使用不是一朝一夕的事了</p><blockquote><p><code>h</code>：模式空间–&gt;覆盖–&gt;保持空间<br><code>H</code>：模式空间–&gt;追加–&gt;保持空间（加在原有内容之后）<br><code>g</code>：保持空间–&gt;覆盖–&gt;模式空间<br><code>G</code>：保持空间–&gt;追加–&gt;模式空间（加在原有内容之后）<br><code>x</code>：模式空间&lt;–交换–&gt;保持空间<br><code>d</code>：删除模式空间中的内容<br><code>D</code>：如果模式空间中的内容为多行时，删除模式空间中的第一行<br><code>n</code>：读取匹配到的行的下一行到模式空间中（覆盖原内容）<br><code>N</code>：读取匹配到的行的下一行到模式空间中（追加在原内容之后）</p></blockquote><p><strong>tips</strong>：多处命令间用分号隔开，实现多点编辑，追加或覆盖操作时原空间内容依然存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sed -n &apos;n;p&apos; file        # 显示偶数行</span><br><span class="line">sed &apos;/^$/d;G&apos; file       # 删除文件中空白行，再为每行后添加空白行(保持空间为空追加模式空间即加空白行)</span><br><span class="line">sed -r &apos;$!N;$!D&apos; file    # 取出最后两行</span><br><span class="line">sed &apos;1!G;h;$!d&apos; file     # 逆序显示</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django使用redirect时重定向到错误端口</title>
      <link href="/2017/12/19/django_redirect_error_port/"/>
      <url>/2017/12/19/django_redirect_error_port/</url>
      
        <content type="html"><![CDATA[<p>Django使用nginx非80端口做反代理，用<code>redirect()</code>或<code>HttpResponseRedirect()</code>进行url重定向时，会默认重定向到80端口。</p><p>解决办法：</p><p>当一个Django应用部署在代理或负载均衡器后面的时候，解决这个问题需要依赖 X-Forwarded-Host 报头提供转发地址。</p><p>首先，添加下面字段到 nginx 的主机配置文件（插入到 location 部分），用于配置 nginx 发送出合适的报头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">proxy_set_header X-Forwarded-Host $host:端口号;</span><br><span class="line"></span><br><span class="line"><span class="comment"># for instance</span></span><br><span class="line">proxy_set_header X-Forwarded-Host $host:<span class="number">8000</span>;</span><br></pre></td></tr></table></figure><a id="more"></a><p>其次，添加下面字段到 Django settings.py 文件，用于配置 Django 信任接收到的 X-Forwarded-Host 报头：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE_X_FORWARDED_HOST = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>现在它应该能正常工作了。</p><p>另外，出于安全原因，应用不应该无条件信任接收到的 X-Forwarded-Host 参数，正确的做法是在Djangosettings.py的ALLOWED_HOSTS配置中加入可信任的域名或者IP。</p><p>参考:<br><a href="https://stackoverflow.com/questions/8591189/django-admin-redirects-to-wrong-port-on-save" target="_blank" rel="noopener">django admin redirects to wrong port on save</a></p>]]></content>
      
      
      <categories>
          
          <category> Django </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux启动流程</title>
      <link href="/2017/12/05/linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
      <url>/2017/12/05/linux%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>了解linux启动过程，让我们能对启动问题快速定位和深入了解linux运行原理。</p><p>linux启动流程概况</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjhy3ibtj30lc0jeq4i.jpg" alt="booting-process"><br><a id="more"></a></p><p>以下对每一过程详细叙述</p><h3 id="硬件启动阶段"><a href="#硬件启动阶段" class="headerlink" title="硬件启动阶段"></a>硬件启动阶段</h3><ul><li>POST（power on system test）上电自检，实现这一自检功能的是固化在主板上的ROM(主要代表为CMOS)芯片上的BIOS(Basic Input/Output System)程序。主板在接通电源后，BIOS系统对CPU、主板、内存、硬盘子系统、显示子系统串并行接口、键盘、CD-ROM光驱等硬件进行检测，检测完成之后就进行硬件设备的初始化。</li><li>BOIS按照bootsequence中的启动顺序加载设备，在选择启动设备之后就可以读取这个设备上位于MBR里的bootloader了。</li></ul><p>MBR结构</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gji4or94j30db0d10t2.jpg" alt="MBR"></p><p>MBR（Master Boot Record）主引导记录，是计算机开机后访问硬盘时所必须要读取的首个扇区，其结构如图所示，由以下部分组成：</p><ul><li><code>主引导记录(446Bytes)</code>存放bootloader</li><li><code>分区表(64Bytes)</code>分区表信息</li><li><code>结束标志(2Bytes)</code>  检验主引导记录是否有效</li></ul><h3 id="BootLoader引导阶段"><a href="#BootLoader引导阶段" class="headerlink" title="BootLoader引导阶段"></a>BootLoader引导阶段</h3><ul><li>加载grub，根据选择加载不同的内核或者操作系统版本。</li><li>grub把内核文件载入到内存的同时，把ramdisk（临时根文件系统）也在载入到内存中。随后把控制权移交给内核。</li></ul><p><strong>什么是grub？</strong><br>在linux中常见的BootLoader有lilo grub两种 ，lilo小而精悍，用于早期的linux版本中，现在适用于安卓手机，grub功能强大取代了Lilo，被各大linux版本所采用，现在centos7中大多采用grub的新版本grub2（下文所说的grub都是grub2）。<br>在grub中提供菜单让用户去选择要启动的系统或不同的内核版本，还提供了命令行工具，显然在MBR只有512Bytes，不能存放这么多东西。grub为了打破在MBR中只有446Bytes用于存放bootloader这一限制，grub是通过分成三个阶段来实现：</p><ul><li><code>stage1</code> 存放于MBR的前446Bytes，用于加载stage1.5阶段，目的是为了识别并驱动stage2(或者/boot)所在分区的文件系统；</li><li><code>stage1.5</code> 存放于MBR之后的扇区，加载stage2所在分区的文件系统驱动，让stage1中的bootloader能识别stage2所在分区的文件系统；</li><li><code>stage2</code> 存放于磁盘分区之上，具体存放于/boot/grub目录之下，主要用于加载内核文件(vmlinuz-VERSION-RELEASE)以及ramdisk这个临时根文件系统(initrd-VERSION-RELEASE.img或initramfs-VERSION-RELEASE.img)。</li></ul><p>通过三阶段的加载，grub在不依赖于根文件系统的前提下（此时还没有根文件系统），成功识别/boot分区的文件系统，加载/boot目录了下的ramdisk和vmlinuz内核文件了。</p><p> <strong>什么是ramdisk？</strong><br><code>ramdisk</code>是用于实现系统初始化的、基于内存的磁盘设备。即加载至内存（的某一段空间）后把内存当磁盘使用，并在内存中作为临时根文件系统提供给内核使用，帮助内核挂载真正的根文件系统。</p><p><code>ramdisk</code>之所以能够帮助内核挂载根文件系统是因为在ramdisk这个临时文件系统的/lib/modules目录下有真正的根文件系统所在设备的驱动程序；除此之外，这个临时文件系统也遵循FHS，例如有这些固定目录结构：/bin, /sbin, /lib, /lib64, /etc, /mnt, /media, …</p><p><code>ramdisk</code>在内存中被当做磁盘使用，kernel会默认为其加载的虚文件系统，在内存中再次缓冲/缓存。这样大大影响了加载速度。CentOS 5系列以及之前版本的ramdisk文件为<code>initrd-VERSION-RELEASE.img</code>，就会出现上述所提到到的问题；而为了解决这一问题，CentOS 6/7系列版本就将其改为<code>initramfs-VERSION-RELEASE.img</code>，使用文件系统的方式就可以避免双缓冲/缓存了，起到了提速作用。</p><h3 id="kernel引导阶段"><a href="#kernel引导阶段" class="headerlink" title="kernel引导阶段"></a>kernel引导阶段</h3><p>内核在内存中完成自解压，随后进行系统自身初始化：</p><ul><li>探测可识别到的硬件设备</li><li>加载真正的根文件系统驱动程序（借助于ramdisk）。</li><li>以<code>只读</code>的方式挂载根文件系统。</li><li>运行用户空间的第一个程序init。</li></ul><p><code>Note</code> 此时Linux内核仍在启动阶段是不稳定的，防止在启动时发生不可预知的错误破坏文件系统上的数据。</p><h3 id="init初始化"><a href="#init初始化" class="headerlink" title="init初始化"></a>init初始化</h3><p>init进程的更替：<br><code>sysvinit</code> —&gt; <code>upstart</code> —&gt; <code>systemd</code></p><ul><li><p><code>Sysvinit</code> system V风格的init系统：通过脚本串行启动服务。详细信息：<a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init1/index.html?ca=drs-" target="_blank" rel="noopener">浅析Linux初始化init系统,第1部分</a></p></li><li><p><code>UpStart</code> 基于事件驱动的方式，通过脚本几乎并行的启动服务。详细信息：<a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html?ca=drs-" target="_blank" rel="noopener">浅析Linux初始化init系统，第2部分</a></p></li><li><code>Systemd</code> 真正的并发启动，同时去除了脚本启动带来的开销（脚本里的每个命令都会创建一个子进程），极大地提高了系统启动速度；用CGroup 统计跟踪子进程，干净可靠。更多特性：<a href="https://www.ibm.com/developerworks/cn/linux/1407_liuming_init2/index.html?ca=drs-" target="_blank" rel="noopener">浅析Linux初始化init系统，第3部分</a></li></ul><p>由于systemd的优秀特性，在新的发行版中更为广泛地使用。<br>下文分别对CentOS6和CentOS7启动作为说明：</p><h4 id="CentOS6"><a href="#CentOS6" class="headerlink" title="CentOS6"></a><strong>CentOS6</strong></h4><ul><li>根据init配置文件<code>/etc/inittab</code>设置默认运行级别<blockquote><p>0：关机模式，shutdown；<br>   1：单用户模式(single user)：不需要通过认证，登录进去之后为root用户身份，是维护模式；<br>   2：多用户模式(multi user)：会启动网络功能，但不会启动NFS，是维护模式；<br>   3：多用户模式(multi user)：为完全功能模式，提供文本界面；<br>   4：预留级别，目前无特别使用目的，但习惯上以同3级别功能来使用；<br>   5：多用户模式(multi user)：为完全功能模式，提供图形界面；<br>   6：重启模式，reboot；</p></blockquote></li><li><p>运行系统初始化脚本<code>/etc/rc.d/rc.sysinit</code>，完成系统初始化</p><blockquote><p>①设置主机名；<br> ②设置欢迎信息；<br> ③激活udev和selinux；<br> ④挂载/etc/fstab文件中定义的所有文件系统；<br> ⑤检测根文件系统，以读写方式重新挂载根文件系统；<br> ⑥设置系统时钟；<br> ⑦根据/etc/sysctl.conf文件来设置内核参数；<br> ⑧激活lvm及软raid设备；<br> ⑨激活swap设备；<br> ⑩加载额外设备的驱动程序（因为内核只加载根文件系统所在分区的驱动程序）；</p></blockquote></li><li><p>关闭或启动用户选定的默认运行级别下所对应的服务<br> <code>/etc/rc.d/rc#.d/</code>目录下的脚本(#代表运行级别)</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">K<span class="comment">##*：表示要停止的服务；'##'表示关闭优先级，数字越小，越是优先关闭；依赖到其他服务的服</span></span><br><span class="line">     务会优先关闭，而被依赖的服务则后关闭；</span><br><span class="line">      </span><br><span class="line">S<span class="comment">##*：表示要启动的服务；'##'表示启动优先级，数字越小，越是优先启动；被依赖的服务会优先</span></span><br><span class="line">     启动，而依赖到其他服务的服务则后启动；</span><br></pre></td></tr></table></figure></li><li><p>启动终端，打印登录提示符 </p></li></ul><h4 id="CentOS7"><a href="#CentOS7" class="headerlink" title="CentOS7"></a><strong>CentOS7</strong></h4><p>systemd读取由<code>/etc/systemd/system/default.target</code>链接的文件（链接到此<code>/usr/lib/systemd/system/multi-user.target</code>）以确定默认系统目标（相当于运行级别）。系统目标文件定义了systemd启动的服务。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/default.target</span><br><span class="line"></span><br><span class="line">[Unit]                                 <span class="comment"># unit文件</span></span><br><span class="line">Description=Multi-User System          <span class="comment"># 指明启动的等级</span></span><br><span class="line">Documentation=man:systemd.special(7)</span><br><span class="line">Requires=basic.target</span><br><span class="line">Conflicts=rescue.service rescue.target</span><br><span class="line">After=basic.target rescue.service rescue.target</span><br><span class="line">AllowIsolate=yes</span><br></pre></td></tr></table></figure></p><p>Sysvinit 运行级别和 systemd 目标的对应表</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjifndxxj30wg0i3q4w.jpg" alt="Sysvinit 运行级别和 systemd 目标的对应表"></p><p>systemd将系统置于系统<code>target</code>所定义的状态，执行系统初始化任务：</p><blockquote><p>1.设置主机名<br>2.初始化网络<br>3.根据配置初始化SELinux<br>4.打印欢迎信息<br>5.初始化系统基于内核引导参数的硬件<br>6.安装文件系统，包括诸如/roc文件系统的虚拟文件系统清理/var中的目录<br>8.激活交换设备</p></blockquote><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.thegeekdiary.com/centos-rhel-7-booting-process/" target="_blank" rel="noopener">CentOS/RHEL7:Booting process</a><br><a href="https://opensource.com/article/17/2/linux-boot-and-startup" target="_blank" rel="noopener">Linux boot and startup processes</a><br><a href="http://blog.51cto.com/xuweitao/1900398" target="_blank" rel="noopener">CentOS系统启动流程</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Booting-process </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux IO Scheduler</title>
      <link href="/2017/12/05/Linux%20IO%20Scheduler/"/>
      <url>/2017/12/05/Linux%20IO%20Scheduler/</url>
      
        <content type="html"><![CDATA[<h3 id="I-O-scheduler（I-O-调度器）"><a href="#I-O-scheduler（I-O-调度器）" class="headerlink" title="I/O scheduler（I/O 调度器）"></a>I/O scheduler（I/O 调度器）</h3><p> I/O scheduler （也叫做 I/O elevator）在linux中，每个块设备或者块设备的分区，都对应有自身的请求队列(request_queue),而每个请求队列都可以选择一个I/O调度器来协调所递交的request。I/O调度器的基本目的是将请求按照它们对应在块设备上的扇区号进行排列，以减少磁头的移动，提高效率。</p><p>Linux IO Scheduler在所处位置：</p><p> <img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjgwaadtj30dw0eigm1.jpg" alt="I/O scheduler"><br><a id="more"></a></p><h3 id="I-O-调度策略"><a href="#I-O-调度策略" class="headerlink" title="I/O 调度策略"></a>I/O 调度策略</h3><p>I/O请求队列的四种调度策略：</p><ul><li><code>NOOP</code> 此算法实现简单的FIFO调度队列。适用于不需要调度算法对I/O队列进行调整场景，例如非旋转型设备（SSD、ramdisk）。</li><li><code>CFQ</code> 类似于CPU时间片，此算法实现了I/O时间片，使用I/O优先级来确定，该进程的请求队列何时可以获取块设备的使用权。保证每一个进程I/O请求的公平性。适用于大多数场景。注意：不同于其他调度算法的是：<code>此算法的对象是进程</code>，可以理解该算法对某些I/O密集型的进程不友好。</li><li><code>Deadline</code> I/O请求的“最后期限”到来时，把这个I/O请求优先级推到最高。适用于读多写少的场景。默认情况下，读请求的超时时间是500ms，写请求的超时时间是5s。</li><li><code>Anticipatory</code> 此算法的实现过程是：当一个I/O读请求做完后，再等待一定时间t（通常是6ms），如果6ms内，这个进程上还有读请求过来，那么会继续服务，否则，处理下一个进程的读写请求。因为可以配置CFQ调参数来达到和其一样的效果，但是Anticipatory比CFQ系统开销高，在linux2.6.33版本后被CFQ所取代。</li></ul><p>在调节之前，需要了解所调整的环境的工作负载类型才能选择合适的scheduler 。</p><hr><h3 id="I-O-Scheduler修改"><a href="#I-O-Scheduler修改" class="headerlink" title="I/O Scheduler修改"></a>I/O Scheduler修改</h3><p>在centos7中 I/O Scheduler ，CFQ用于SATA 硬盘 ，Deadline 用于其他硬盘。<br>查看调度策略：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/block/sda/queue/scheduler</span><br><span class="line">noop [deadline] cfq</span><br></pre></td></tr></table></figure></p><h4 id="修改调度算法"><a href="#修改调度算法" class="headerlink" title="修改调度算法"></a>修改调度算法</h4><h4 id="临时修改："><a href="#临时修改：" class="headerlink" title="临时修改："></a>临时修改：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"cfq"</span> &gt; /sys/block/sda/queue/scheduler</span><br><span class="line">cat /sys/block/sda/queue/scheduler</span><br><span class="line">noop deadline [cfq]</span><br></pre></td></tr></table></figure><h4 id="永久修改"><a href="#永久修改" class="headerlink" title="永久修改"></a>永久修改</h4><p>永久修改需要在BootLoader加载内核时，给内核传递参数<code>elevator=noop/deadline/cfq</code></p><p>在Centos7中<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grubby --update-kernel=ALL --args=<span class="string">"elevator=cfq"</span></span><br></pre></td></tr></table></figure></p><p>Note：<code>grubby</code>用于在多个体系结构中配置BootLoader菜单的命令行工具，该工具会修改<code>/boot/grub2/grub.cfg</code>文件，更多信息通过man查看。</p><p>查看修改情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># On BIOS-based machines:/boot/grub2/grub.cfg           # BIOS启动</span></span><br><span class="line"><span class="comment"># On UEFI-based machines:/boot/efi/EFI/redhat/grub.cfg  # UEFI启动 </span></span><br><span class="line"></span><br><span class="line">cat /boot/grub2/grub.cfg |grep elevator</span><br><span class="line"><span class="comment">#给内核传递参数elevator</span></span><br><span class="line">linux16 /vmlinuz-3.10.0-693.5.2.el7.x86_64 root=/dev/mapper/cl-root ... rhgb quiet elevator=noop</span><br></pre></td></tr></table></figure></p><p>在CentOS6中<br>在centos6需要直接修改配置文件。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/default/grub</span><br><span class="line"></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">"elevator=noop"</span>   <span class="comment"># 这一行是存在，在引号内追加。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># On BIOS-based machines:  </span></span><br><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># On UEFI-based machines:</span></span><br><span class="line">grub2-mkconfig -o /boot/efi/EFI/redhat/grub.cfg</span><br></pre></td></tr></table></figure></p><p>注意：最终修改文件都是<code>/boot/grub2/grub.cfg</code>，当然你也可以直接修改此文件。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.certdepot.net/rhel7-configure-io-schedulers/" target="_blank" rel="noopener">RHEL7: How to configure I/O schedulers.</a><br><a href="https://access.redhat.com/solutions/32376" target="_blank" rel="noopener">Using the Deadline IO Scheduler</a><br><a href="http://www.cnblogs.com/cobbliu/p/5389556.html" target="_blank" rel="noopener">Linux IO Scheduler（Linux IO 调度器）</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I/O schedulers </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之链式线性表（Python版）</title>
      <link href="/2017/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E5%BC%8F%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88Python%E7%89%88%EF%BC%89/"/>
      <url>/2017/11/30/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E5%BC%8F%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88Python%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。这些数据元素可以存在内存未被占用的任意位置。链式结构中，除了要存<code>数据元素</code>信息外，还要存储它的<code>后继元素的存储地址</code>。<br>存储数据元素信息的域称为<code>数据域</code>，存储直接后继位置的域称为<code>指针域</code>。指针域中存储的信息称做指针或链。这两部分信息组成数据元素的存储映像，称为<code>结点（Node）</code>或节点。其结构如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk77uekzj30w00ai40q.jpg" alt="链式线性表"><br><a id="more"></a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>Python中没有指针这一概念，以下代码通过类的方式实现，相比C语言少去了申请和释放内存的操作，其思想一致。。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__head = <span class="literal">None</span></span><br><span class="line">        self.__tail = <span class="literal">None</span></span><br><span class="line">        self.__length = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isEmpty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__length == <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""链表长度"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__length</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""遍历链表"""</span></span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            print(<span class="string">"list is empty"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.__head</span><br><span class="line">            i = <span class="number">1</span></span><br><span class="line">            list = []</span><br><span class="line">            <span class="keyword">while</span> i &lt;= self.__length:</span><br><span class="line">                list.append(cur.elem)</span><br><span class="line">                cur = cur.next</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            print(<span class="string">"===&gt;Llist : length:%d"</span> % self.__length, list)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        <span class="string">"""链表头部添加元素"""</span></span><br><span class="line">        node = Node(elem)</span><br><span class="line"></span><br><span class="line">        node.next = self.__head</span><br><span class="line">        self.__head = node</span><br><span class="line">        self.__length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        <span class="string">"""链表尾部添加元素"""</span></span><br><span class="line">        node = Node(elem)</span><br><span class="line">        <span class="keyword">if</span> self.isEmpty():</span><br><span class="line">            self.__tail = self.__head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.__tail.next = node</span><br><span class="line">            self.__tail = node</span><br><span class="line">        self.__length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, elem)</span>:</span></span><br><span class="line">        <span class="string">"""指定位置添加元素"""</span></span><br><span class="line">        <span class="keyword">if</span> pos &gt; self.__length:</span><br><span class="line">            print(<span class="string">"the List length is %d"</span>, self.__length)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> pos &lt; <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"please correct index"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> pos == <span class="number">0</span>:</span><br><span class="line">            self.add(elem)</span><br><span class="line">        <span class="keyword">elif</span> pos == self.__length:</span><br><span class="line">            self.append(elem)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node = Node(elem)</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="keyword">while</span> i &lt;= pos - <span class="number">2</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            node.next = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            self.__length += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Remove</span><span class="params">(self, pos)</span>:</span></span><br><span class="line">        <span class="string">"""删除节点"""</span></span><br><span class="line">        <span class="keyword">if</span> pos &gt; self.__length:</span><br><span class="line">            print(<span class="string">"the List length is %d"</span>, self.__length)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> pos &lt; <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"please correct index"</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> pos == <span class="number">0</span>:</span><br><span class="line">            self.__head = self.__head.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="keyword">while</span> i &lt;= pos - <span class="number">2</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur.next <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 删除尾节点</span></span><br><span class="line">                cur.next = <span class="literal">None</span></span><br><span class="line">                self.__tail = cur</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur.next = cur.next.next</span><br><span class="line">            self.__length -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Search</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        <span class="string">"""查找节点是否存在"""</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        i = <span class="number">0</span></span><br><span class="line">        list = []</span><br><span class="line">        <span class="keyword">while</span> cur != self.__tail:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == elem:</span><br><span class="line">                list.append(i)</span><br><span class="line">                print(list)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    Llist = SingleLinkList()</span><br><span class="line"></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">        Llist.append(random.randint(<span class="number">0</span>, <span class="number">100</span>))</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    Llist.travel()</span><br><span class="line"></span><br><span class="line">    Llist.add(<span class="number">3</span>)</span><br><span class="line">    Llist.travel()</span><br><span class="line"></span><br><span class="line">    Llist.insert(<span class="number">6</span>, <span class="number">90</span>)</span><br><span class="line">    Llist.travel()</span><br><span class="line"></span><br><span class="line">    Llist.Search(<span class="number">90</span>)</span><br><span class="line"></span><br><span class="line">    Llist.Remove(<span class="number">11</span>)</span><br><span class="line">    Llist.travel()</span><br></pre></td></tr></table></figure><p>以上代码有两个地方的改变，不知道合不合理：<br>链表的结构中存储除头指针以外的<code>尾节点</code>和<code>链表长度</code>，这样写的好处是加速了尾节点插入和链表长度频繁获取。</p><h3 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h3><table><thead><tr><th>存储类型</th><th>顺序存储</th><th>单链表</th></tr></thead><tbody><tr><td>存储分配方式</td><td>用一段连续的存储单元依次存储线性表的数据元素</td><td>采用链式存储结构，用一组任意的存储单元存放线性表的元素</td></tr><tr><td>空间性能</td><td>需要预分配存储空间，分大了浪费，小了容易发生上溢</td><td>不需要分配存储空间，只要有就可以分配，元素个数不受限制</td></tr><tr><td>时间性能</td><td>查找<code>O（1）</code>、插入和删除<code>O（n）</code></td><td>查找<code>O（n）</code>、插入和删除<code>O（n）</code></td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>数据插入和删除的时间复杂度：</p><ul><li>顺序表：<code>O（n）= 查找节点O（1）+数据移动O（n）</code></li><li>单链表：<code>O（n）= 查找节点O（n）+数据操作O（1）</code></li></ul><p>通过以上对比，可得出一些经结论：<br>链表改进了顺序表的在做数据修改或插入时的数据移动操作，同时也不需要预先分配内存空间和连续的空间。但在预知存储空间大小的情况下顺序表一次性分配 ，节省了时间。</p>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LinkList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之线性表（Golang版）</title>
      <link href="/2017/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88Golang%E7%89%88%EF%BC%89/"/>
      <url>/2017/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88Golang%E7%89%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>最近在学习Go语言，最好的温习方式莫过于使用它了。<br>熟悉Go语言的基本语法，顺便也温习一下数据结构。</p><p>线性表结构</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk7qio1zj30w0099tad.jpg" alt="线性表结构"></p><a id="more"></a><p>以下代码是线性表中的顺序存储结构，基本略去了些容错的考虑（容错还要一半的代码），主要以实现功能为主</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//线性表中的顺序存储结构</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">"fmt"</span></span><br><span class="line"><span class="string">"math/rand"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性表中存储的数据类型</span></span><br><span class="line"><span class="keyword">type</span> Elem <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> SqList <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">//最大长度</span></span><br><span class="line">maxsize <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 当前长度</span></span><br><span class="line">length <span class="keyword">int</span></span><br><span class="line"><span class="comment">// 数据</span></span><br><span class="line">data []Elem</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化列表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitList</span><span class="params">(maxsize <span class="keyword">int</span>)</span> *<span class="title">SqList</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;SqList&#123;maxsize: maxsize, data: <span class="built_in">make</span>([]Elem, maxsize)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *SqList)</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span>  <span class="number">0</span> != list.length&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"===&gt; list is empty"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断线性表是否已满</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *SqList)</span> <span class="title">IsFull</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> list.length != list.maxsize &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">"===&gt; list is full"</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引是否越界</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *SqList)</span> <span class="title">IsRange</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &lt; <span class="number">1</span> || i &gt; list.maxsize &#123;</span><br><span class="line">fmt.Printf(<span class="string">"===&gt; index out of range"</span>, list.maxsize)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *SqList)</span> <span class="title">Insert</span><span class="params">(i <span class="keyword">int</span>, e Elem)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> list.IsRange(i) &amp;&amp; list.IsFull() &#123;</span><br><span class="line"><span class="keyword">for</span> index, _ := <span class="keyword">range</span> list.data &#123;</span><br><span class="line"><span class="keyword">if</span> index &gt;= i &#123;</span><br><span class="line">l := list.maxsize - (index - i)</span><br><span class="line">list.data[l] = list.data[l<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">list.data[i] = e</span><br><span class="line">list.maxsize ++</span><br><span class="line">fmt.Printf(<span class="string">"===&gt; index %d is insert val:%d \n"</span>, i, e)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *SqList)</span> <span class="title">Delete</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> list.IsRange(i) &amp;&amp; list.IsEmpty() &#123;</span><br><span class="line"><span class="keyword">for</span> index, _ := <span class="keyword">range</span> list.data &#123;</span><br><span class="line"><span class="keyword">if</span> index &gt;= i &#123;</span><br><span class="line">list.data[index<span class="number">-1</span>] = list.data[index]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">"===&gt; index: %d val :%d is deleted \n"</span>, i, list.data[i])</span><br><span class="line">list.data[list.length<span class="number">-1</span>] = <span class="number">0</span></span><br><span class="line">list.maxsize --</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *SqList)</span> <span class="title">Modify</span><span class="params">(i <span class="keyword">int</span>, e Elem)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> list.IsRange(i) &amp;&amp; list.IsEmpty()&#123;</span><br><span class="line">list.data[i] = e</span><br><span class="line">fmt.Printf(<span class="string">"===&gt; index: %d is modified val :%d\n"</span>, i, e)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 索引查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *SqList)</span> <span class="title">GetElem</span><span class="params">(i <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> list.IsRange(i) &amp;&amp; list.IsEmpty()&#123;</span><br><span class="line">fmt.Printf(<span class="string">"===&gt; get index :%d value :%d \n"</span>, i, list.data[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 值查询</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *SqList)</span> <span class="title">HasElem</span><span class="params">(val Elem)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> list.data &#123;</span><br><span class="line"><span class="keyword">if</span> val == value &#123;</span><br><span class="line">i ++</span><br><span class="line">fmt.Printf(<span class="string">"===&gt; the value: %d is exist,num:%d \n"</span>,val, i)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 追加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(list *SqList)</span> <span class="title">Append</span><span class="params">(e Elem)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> list.IsFull() &#123;</span><br><span class="line">list.data[list.length] = e</span><br><span class="line">list.length ++</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">sq := InitList(<span class="number">30</span>) <span class="comment">// 序列表初始化</span></span><br><span class="line"></span><br><span class="line">num := <span class="number">30</span>  <span class="comment">//append 数量</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= num; i++ &#123;</span><br><span class="line">r := rand.New(rand.NewSource(<span class="keyword">int64</span>(i))) <span class="comment">//New(rand.NewSource(time.Now().UnixNano())</span></span><br><span class="line"><span class="keyword">if</span> sq.Append(Elem(r.Intn(<span class="number">100</span>))) &amp;&amp; i == num &#123;</span><br><span class="line">fmt.Println(<span class="string">"append success! "</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(sq)</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"*****Testing: *****"</span>)</span><br><span class="line">sq.Delete(<span class="number">25</span>)</span><br><span class="line">fmt.Println(sq)</span><br><span class="line"></span><br><span class="line">sq.Insert(<span class="number">20</span>, <span class="number">5</span>)</span><br><span class="line">fmt.Println(sq)</span><br><span class="line"></span><br><span class="line">sq.GetElem(<span class="number">25</span>)</span><br><span class="line">fmt.Println(sq)</span><br><span class="line"></span><br><span class="line">sq.HasElem(<span class="number">48</span>)</span><br><span class="line">fmt.Println(sq)</span><br><span class="line"></span><br><span class="line">sq.Modify(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">fmt.Println(sq)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DataStructure </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SequenceList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>集群问题</title>
      <link href="/2017/10/27/cluster_problems/"/>
      <url>/2017/10/27/cluster_problems/</url>
      
        <content type="html"><![CDATA[<h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><ul><li><p><code>http重定向</code> 应用层的请求转发。用户的请求到达客户端后，服务端返回HTTP重定向码（302、301），客户端接收重定向码后再次请求<code>real server</code>。</p></li><li><p><code>DNS域名解析负载均衡</code> 在用户请求DNS服务器，获取域名对应的IP地址时，DNS解析后有多个IP地址，DNS服务器通过轮询的方式分发请求。</p></li><li><p><code>反向代理服务器</code>在用户的请求到达反向代理服务器时，由反向代理服务器根据算法转发到具体的服务器。常用apache，nginx充当反向代理服务器。</p></li><li><p><code>IP层负载均衡</code>在请求到达负载均衡器后，负载均衡器通过修改请求的目的IP地址，从而实现请求的转发，做到负载均衡。</p></li><li><p><code>数据链路层负载均衡</code>在请求到达负载均衡器后，负载均衡器通过修改请求的mac地址，从而做到负载均衡，与IP负载均衡不一样的是，当请求访问完服务器之后，直接返回客户。而无需再经过负载均衡器。</p><a id="more"></a><h3 id="负载均衡调度策略"><a href="#负载均衡调度策略" class="headerlink" title="负载均衡调度策略"></a>负载均衡调度策略</h3><p>根据调度连接状态，分为以下两种调度算法：</p><h4 id="静态调度算法"><a href="#静态调度算法" class="headerlink" title="静态调度算法"></a>静态调度算法</h4></li><li><p><code>rr</code> 轮询调度算法：顾名思义，轮询分发请求。这种方式实现简单<br>但没有考虑每台服务器的处理能力。</p></li><li><p><code>wrr</code> 加权调度算法：给每个服务器设置权值weight，负载均衡调度器根据权值调度服务器，服务器被调用的次数跟权值成正比。</p></li></ul><ul><li><p><code>sh</code> 原地址散列：提取用户IP，根据散列函数得出一个key，再根据静态映射表，查处对应的value，即目标服务器IP。如果目标机器超负荷，则返回空。</p></li><li><p><code>dh</code> 目标地址散列：同上，只是现在提取的是目标地址的IP来做哈希。以上两种算法的都能实现同一个用户访问同一个服务器。</p></li></ul><h4 id="动态调度算法"><a href="#动态调度算法" class="headerlink" title="动态调度算法"></a>动态调度算法</h4><ul><li><code>lc</code>最少连接。优先把请求转发给连接数少的服务器。使得集群中各个服务器的负载更加均匀。</li><li><code>wlc</code>加权最少连接。在lc的基础上，为每台服务器加上权值。算法为：（活动连接数*256+非活动连接数）/权重，计算出来的值小的服务器优先被选择。这种算法可以根据服务器的能力分配请求。</li><li><code>sed</code> 最短期望延迟。其实sed跟wlc类似，区别是不考虑非活动连接数。算法为：（活动连接数+1)*256÷权重，同样计算出来的值小的服务器优先被选择。</li><li><code>nq</code> 永不排队。改进的sed算法。我们想一下什么情况下才能“永不排队”，那就是服务器的连接数为0的时候，那么假如有服务器连接数为0，均衡器直接把请求转发给它，无需经过sed的计算。</li><li><code>LBLC</code> 基于局部性的最少连接。均衡器根据请求的目的IP地址，找出该IP地址最近被使用的服务器，把请求转发之，若该服务器超载，最采用最少连接数算法。</li><li><code>LBLCR</code> 带复制的基于局部性的最少连接。均衡器根据请求的目的IP地址，找出该IP地址最近使用的“服务器组”，注意，并不是具体某个服务器，然后采用最少连接数从该组中挑出具体的某台服务器出来，把请求转发之。若该服务器超载，那么根据最少连接数算法，在集群的非本服务器组的服务器中，找出一台服务器出来，加入本服务器组，然后把请求转发之。</li></ul><h3 id="session一致性和同步"><a href="#session一致性和同步" class="headerlink" title="session一致性和同步"></a>session一致性和同步</h3><ul><li><p><code>Session Sticky</code>把同一个用户在某一个会话中的请求，都分配到固定的某一台服务器中，这样我们就不需要解决跨服务器的session问题了，常见的算法有ip_hash法，即上面提到的两种散列算法。这种方式实现简单，但session值只存在一台服务器上，容易单点故障。</p></li><li><p><code>Session Replication</code>在集群中复制session，使得每个服务器都保存有全部用户的session数据。这种方式从缓存命中率方面，减轻负载均衡服务器的压力，但是复制时宽带开销大，访问量大的话session占用内存大且浪费。</p></li><li><p><code>Session数据集中存储</code>利用数据库来存储session数据，实现了session和应用服务器的解耦。也可以使用其他分布式存储系统，这种方式就是要维护seeion数据。</p></li><li><p><code>Cookie Base</code> 把session加密后存储在cookie中，当浏览器来告诉应用服务器session，同样实现了session和应用服务器的解耦。这种方式实现简单避免了维护session的麻烦，但存在安全隐患和请求的并发数。<br>详细解释：<a href="http://blog.csdn.net/Heng_Ji/article/details/53436635" target="_blank" rel="noopener">集群session一致性和同步问题</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Architecture </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cluster </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack--网络环境实践(二)</title>
      <link href="/2017/10/24/OpenStack2/"/>
      <url>/2017/10/24/OpenStack2/</url>
      
        <content type="html"><![CDATA[<p>本实验将多台物理主机中的虚拟主机组合，在主机A（计算节点）的虚拟主机形成局域网，同时通过主机B（控制节点）对外通信。。。</p><p>网络拓扑图</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gj9qxy26j312s0m4jvh.jpg" alt="enter description here"><br><a id="more"></a></p><p>外网地址规划<br>主机A作为计算节点，B作为网络控制节点，网关和DNS服务器为为<code>192.168.153.2</code></p><table><thead><tr><th>主机</th><th>IP</th></tr></thead><tbody><tr><td>A ens33</td><td>192.168.153.141/24</td></tr><tr><td>B ens33</td><td>192.168.153.142/24</td></tr></tbody></table><p>内网网络地址规划</p><table><thead><tr><th>主机</th><th>IP</th></tr></thead><tbody><tr><td>A ens37</td><td>192.168.10.1/24</td></tr><tr><td>B ens37</td><td>192.168.10.2/24</td></tr></tbody></table><p>虚拟网络地址规划<br><code>10.0.4.200 -- 10.0.4.220</code>由A主机网络名称空间<code>dnsmasq</code>提供</p><table><thead><tr><th>主机</th><th>IP</th></tr></thead><tbody><tr><td>VM1</td><td>10.0.4.215/24</td></tr><tr><td>VM2</td><td>10.0.4.210/24</td></tr><tr><td>VM3</td><td>10.0.4.211/24</td></tr><tr><td>DHCP</td><td>10.0.4.224/24</td></tr><tr><td>NS rin0</td><td>10.0.4.223/24</td></tr><tr><td>NS rex0</td><td>192.168.153.145/24</td></tr></tbody></table><p>接<a href="https://www.nova-he.github.io/2017/09/28/OpenStack2/" target="_blank" rel="noopener">OpenStack–网络环境实践(一)</a></p><h3 id="桥接物理网卡设备"><a href="#桥接物理网卡设备" class="headerlink" title="桥接物理网卡设备"></a>桥接物理网卡设备</h3><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gja0lul3j30kb08waaz.jpg" alt="enter description here"></p><p>如图只需将虚拟交换机连到外网，即可通信~ 至于为什么加一个名称空间，因为名称空间可以方便快捷的管理虚拟机局域网络。</p><p>创建物理桥设备,并将网卡桥接到物理网卡上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vim /etc/sysconfig/network-script/ifcfg-br0</span><br><span class="line"></span><br><span class="line">TYPE=Bridge</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">PEERDNS=yes</span><br><span class="line">PEERROUTES=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">NAME=br0</span><br><span class="line">DEVICE=br0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.153.141</span><br><span class="line">GATEWAY=192.168.153.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 清除ifcfg-ens33配置地址</span><br><span class="line"> vim /etc/sysconfig/network-scripts/ifcfg-ens33 </span><br><span class="line"></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">NAME=ens33</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line"></span><br><span class="line"># 重启网络并把物理网卡加到物理桥上</span><br><span class="line">yum install bridge-uils</span><br><span class="line">systemctl restart network &amp;&amp; brctl addif br0</span><br></pre></td></tr></table></figure><h3 id="虚拟机与域名空间通信"><a href="#虚拟机与域名空间通信" class="headerlink" title="虚拟机与域名空间通信"></a>虚拟机与域名空间通信</h3><p>给虚拟主机VM2添加网关</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjaaei04j30ms04s3zw.jpg" alt="enter description here"></p><blockquote><p>可能遇到的问题：当默认网关存在多个时，ping报文可能不被送出<br>解决办法：删除其他默认的网关</p></blockquote><p>在名称空间打开路由转发功能，使其能和域名空间内另一块网卡通信<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns  sysctl -w net.ipv4.ip_forward=1</span><br></pre></td></tr></table></figure></p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjajhr7pj30t307wn02.jpg" alt="enter description here"><br>现在能与网络空间<code>NS</code>的另一块网卡(IP:192.168.153.143)通信</p><h3 id="虚拟机与宿主机同一网段内的其他主机通信"><a href="#虚拟机与宿主机同一网段内的其他主机通信" class="headerlink" title="虚拟机与宿主机同一网段内的其他主机通信"></a>虚拟机与宿主机同一网段内的其他主机通信</h3><p>虚拟机处于路由模型向外发送数据，相应包无法送回，与宿主机的其他主机(192.168.153.143)不能通信，添加iptables NAT规则，变为nat模型网络向外通信…<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec ns iptables -t nat -A POSTROUTING -s 10.0.4.0/24 -j SNT --to-source 192.168.153.145 </span><br><span class="line">ip netns exec ns iptables -t nat -A PREROUTING -d 192.168.153.145 -j DNAT --to-destination 10.0.4.210</span><br></pre></td></tr></table></figure></p><p>ping宿主机内的其他主机</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjatuaeej30v706rgo2.jpg" alt="enter description here"><br>主机能正常通信</p><p>在<code>192.168.153.143</code>的主机抓包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tcpdump -i ens33 icmp -nn</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on ens33, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">05:43:50.612719 IP 192.168.153.145 &gt; 192.168.153.143: ICMP echo request, id 2561, seq 0, length 64</span><br><span class="line">05:43:50.612766 IP 192.168.153.143 &gt; 192.168.153.145: ICMP echo reply, id 2561, seq 0, length 64</span><br></pre></td></tr></table></figure></p><h3 id="主机与外网通信"><a href="#主机与外网通信" class="headerlink" title="主机与外网通信"></a>主机与外网通信</h3><p>主机不能与互联网通信，在B主机ens37抓包查看原因<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tcpdump -i ens37 -nn</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on ens37, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">03:00:48.272041 IP 192.168.10.1 &gt; 192.168.10.2: GREv0, length 102: IP 10.0.4.210 &gt; 59.110.231.224: ICMP echo request, id 3585, seq 238, length 64</span><br><span class="line">03:00:48.272406 IP 192.168.10.2 &gt; 192.168.10.1: GREv0, length 130: IP 10.0.4.253 &gt; 10.0.4.210: ICMP net 59.110.231.224 unreachable, length 92   #报文能到达网关，网关回应没有路由</span><br></pre></td></tr></table></figure></p><p>观察发现：报文能到达网关，网关回应没有路由，于是在域名空间查看路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip netns exec ns route</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">10.0.4.0        0.0.0.0         255.255.255.0   U     0      0        0 rin0</span><br><span class="line">192.168.153.0   0.0.0.0         255.255.255.0   U     0      0        0 rex0</span><br></pre></td></tr></table></figure></p><p>增加路由<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ip netns exec ns route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         192.168.153.2   0.0.0.0         UG    0      0        0 rex0</span><br><span class="line">10.0.4.0        0.0.0.0         255.255.255.0   U     0      0        0 rin0</span><br></pre></td></tr></table></figure></p><p>虚拟机VM2添加域名解析主机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;nameserver 192.168.153.2&quot; &gt; /etc/resolve.conf</span><br></pre></td></tr></table></figure></p><p>主机能与外网通信</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjb2l70oj30ov07t40s.jpg" alt="enter description here"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>GRE</code>技术出现解决了虚拟机在主机之间通信的问题，当然同样的技术还有<code>Vxlan</code>技术。</li><li>这种网络模型实现了虚拟机网络，与真实主机网络的隔离，可以方便的自定义网络。<code>控制节点添加一个IP号，即可映射一台VM主机，这样的外部的真实主机一样的通信</code></li><li>技术带来无限可能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> OpenStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenStack </tag>
            
            <tag> Openvswitch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenStack--网络环境实践(一)</title>
      <link href="/2017/10/23/OpenStack1/"/>
      <url>/2017/10/23/OpenStack1/</url>
      
        <content type="html"><![CDATA[<p>本实验将多台物理主机中的虚拟主机组合，在主机A（计算节点）的虚拟主机形成局域网，同时通过主机B（控制节点）对外通信。。。</p><p>网络拓扑图</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gihjfmahj312t0m4jvh.jpg" alt="enter description here"><br><a id="more"></a></p><p>外网地址规划<br>主机A作为计算节点，B作为网络控制节点，网关和DNS服务器为为<code>192.168.153.2</code></p><table><thead><tr><th>主机</th><th>IP</th></tr></thead><tbody><tr><td>A ens33</td><td>192.168.153.141/24</td></tr><tr><td>B ens33</td><td>192.168.153.142/24</td></tr></tbody></table><p>内网网络地址规划</p><table><thead><tr><th>主机</th><th>IP</th></tr></thead><tbody><tr><td>A ens37</td><td>192.168.10.1/24</td></tr><tr><td>B ens37</td><td>192.168.10.2/24</td></tr></tbody></table><p>虚拟网络地址规划<br><code>10.0.4.200 -- 10.0.4.220</code>由A主机网络名称空间<code>dnsmasq</code>提供</p><table><thead><tr><th>主机</th><th>IP</th></tr></thead><tbody><tr><td>VM1</td><td>10.0.4.215/24</td></tr><tr><td>VM2</td><td>10.0.4.210/24</td></tr><tr><td>VM3</td><td>10.0.4.211/24</td></tr><tr><td>DHCP</td><td>10.0.4.224/24</td></tr></tbody></table><h3 id="实现细节："><a href="#实现细节：" class="headerlink" title="实现细节："></a>实现细节：</h3><p>以下通过虚拟主机在主机中创建并联网过程说明</p><p>主机A中的虚拟主机创建并加入网络环境时，会创建成对的虚拟网卡前一半会生成虚拟主机中，后一半会调用脚本把另一半加入到虚拟交换机上，其命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/libexec/qemu-kvm -name &apos;c1&apos; -m 128 -smp 1 -drive file=cirros-no_cloud-0.3.0-x86_64-disk.img,media=disk,if=virtio, </span><br><span class="line">-net nic,model=virtio,macaddr=52:56:00:00:00:01    # 前半段虚拟网卡加入虚拟机</span><br><span class="line">-net tap,ifname=vif0.0,script=/etc/if-up,downscript=/etc/if-down  # 调用脚本，都半段加入到虚拟交换机上</span><br><span class="line">--daemonize</span><br></pre></td></tr></table></figure></p><p>虚拟主机在加入到网络环境中时，网卡设备会广播的形式发现网络环境中是否有DHCP服务器，发现有DHCP服务器后，虚拟主机会作为客户端请求IP租赁，这时运行在网络名称空间中的dnsmasq会响应客户端，并通过单播的方式，给客户端IP池中的地址。</p><p><strong>各个虚拟主机和其他主机的虚拟机通信？</strong></p><p>通过GRE协议对IP报文再次封装实现，其详细定义如下：</p><blockquote><p><code>GRE（Generic Routing Encapsulation）</code>：通用路由封装协议。定义了在一种网络层协议上封装另一种协议（或同一种协议）。例如：对某些网络层协议（如IP和IPX）的数据报进行封装，使这些被封装的数据报能够在另一个网络层协议（如IP）中传输。同时这种技术也叫隧道<code>Tunnel</code>技术<br>Tunnel是一个虚拟的点对点的连接，在实际中可以看成仅支持点对点连接的虚拟接口，这个接口提供了一条通路使封装的数据报能够在这个通路上传输，并且在一个Tunnel的两端分别对数据报进行封装及解封 。</p></blockquote><p>在虚拟的交换机上通过<code>port</code>的格式<code>type</code>定义了其协议类型默认为<code>Ethernet</code>,只需定义为<code>gre</code>即可，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-vsctl set interface gre1 type=gre options:remote_ip=192.168.10.2 # 指明type为gre</span><br></pre></td></tr></table></figure></p><p>到目前为止虚拟主机有了IP地址后通过虚拟交换机，虚拟交换机通过GRE隧道和其他主机的在一个局域网内通信。</p><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><h4 id="安装所需的包"><a href="#安装所需的包" class="headerlink" title="安装所需的包"></a>安装所需的包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum install -y iproute vnc qemu-kvm dnsmasq</span><br><span class="line"># 也需要安装openvswitch</span><br><span class="line">rpm -iv openvswitch-2.5.3-1.x86_64.rpm</span><br><span class="line"></span><br><span class="line">还需准备cirros镜像</span><br></pre></td></tr></table></figure><h4 id="创建虚拟交换机和域名空间"><a href="#创建虚拟交换机和域名空间" class="headerlink" title="创建虚拟交换机和域名空间"></a>创建虚拟交换机和域名空间</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">systemctl start openvswitch</span><br><span class="line">ovs-vsctl add-br br-in #其实虚拟交换机只是高级的桥设备</span><br><span class="line"># 创建域名空间</span><br><span class="line">ip netns add r0 #添加域名空间</span><br><span class="line">ip link add sif0 type veth peer name rif0  #添加一对网卡</span><br><span class="line">ip link set sif0 up  # 放到交换机上</span><br><span class="line">ip link set rif0 up  # 放到域名空间内</span><br></pre></td></tr></table></figure><h4 id="在域名空间中启动后一半网卡"><a href="#在域名空间中启动后一半网卡" class="headerlink" title="在域名空间中启动后一半网卡"></a>在域名空间中启动后一半网卡</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec r0 ip link set rif0 up  # 域名空间执行命令ip netns &lt;域名空间名称&gt; exec &lt;命令&gt;</span><br><span class="line">ip netns exec r0 ip addr add 10.0.4.254/24 dev rif0</span><br><span class="line">ip netns exec r0 ip addr list</span><br></pre></td></tr></table></figure><h4 id="在域名空间启用dnsmadq"><a href="#在域名空间启用dnsmadq" class="headerlink" title="在域名空间启用dnsmadq"></a>在域名空间启用dnsmadq</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip netns exec r0 dnsmasq -F 10.0.4.200,10.0.4.220,86400 -i rif0</span><br><span class="line">ip netns exec r0 ss -tnlp # 查看是否监听在端口</span><br></pre></td></tr></table></figure><h4 id="在主机上添加虚拟机启动脚本"><a href="#在主机上添加虚拟机启动脚本" class="headerlink" title="在主机上添加虚拟机启动脚本"></a>在主机上添加虚拟机启动脚本</h4><p><code>vim /etc/if-up</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># </span><br><span class="line">bridge=br-in</span><br><span class="line">if [ -n &quot;$1&quot; ];then</span><br><span class="line">    ip link set $1 up</span><br><span class="line">    sleep 1</span><br><span class="line">    osv-svctl add-port $bridge $1  </span><br><span class="line">    [ $? -eq 0 ] &amp;&amp; exit 0 || exit 1</span><br><span class="line">else </span><br><span class="line">    echo &quot;Error:no port specified&quot;</span><br><span class="line">    exit 2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><p><code>vim /etc/if-down</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"># </span><br><span class="line">bridge=br-in</span><br><span class="line">if [ -n &quot;$1&quot; ];then</span><br><span class="line">    ip link $1 down</span><br><span class="line">    sleep 1</span><br><span class="line">    ovs-vsctl del-prot $bridge $1</span><br><span class="line">    [ $? -eq 0 ] &amp;&amp; exit 0 ||exit 1</span><br><span class="line">else </span><br><span class="line">    echo &quot;Error:no port specified&quot;</span><br><span class="line">    exit 2</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></p><h4 id="运行主机"><a href="#运行主机" class="headerlink" title="运行主机"></a>运行主机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 运行虚拟机1</span><br><span class="line">/usr/libexec/qemu-kvm -name &apos;vm1&apos; -m 128 -smp 1 -drive file=cirros-no_cloud-0.3.0-x86_64-disk.img,media=disk,if=virtio, -net nic,model=virtio,macaddr=52:56:00:00:00:01 -net tap,ifname=vif0.0,script=/etc/if-up,downscript=/etc/if-down --daemonize </span><br><span class="line"></span><br><span class="line"># 修改参数后运行虚拟机2 需修改mac地址 接口名称</span><br><span class="line">/usr/libexec/qemu-kvm -name &apos;vm2&apos; -m 128 -smp 1 -drive file=cirros-no_cloud-0.3.0-x86_64-disk.img,media=disk,if=virtio, -net nic,model=virtio,macaddr=52:56:00:00:00:31 -net tap,ifname=vif1.0,script=/etc/if-up,downscript=/etc/if-down --daemonize</span><br></pre></td></tr></table></figure><h4 id="vnc连接主机"><a href="#vnc连接主机" class="headerlink" title="vnc连接主机"></a>vnc连接主机</h4><p>Xshell在安装Xmanager后，开启转发<code>x11</code>,可连连接虚拟机功能</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1giih4186j30ie0gt753.jpg" alt="enter description here"></p><p>运行vnc连接虚拟主机<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vncviewer :5900 &amp;</span><br><span class="line"></span><br><span class="line"># 其间遇到的问题</span><br><span class="line">WARNING! The remote SSH server rejected X11 forwarding request.</span><br><span class="line"># 解决办法</span><br><span class="line">yum install xorg-x11-xauth</span><br><span class="line"></span><br><span class="line">再次运行即可</span><br></pre></td></tr></table></figure></p><p>如图，虚拟主机获取到IP地址</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gijudxqgj30v20dvdkc.jpg" alt="enter description here"></p><h4 id="添加新接口与主机B通信"><a href="#添加新接口与主机B通信" class="headerlink" title="添加新接口与主机B通信"></a>添加新接口与主机B通信</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-vsctl set interface gre1 type=gre options:remote_ip=192.168.10.2</span><br></pre></td></tr></table></figure><h3 id="主机B配置"><a href="#主机B配置" class="headerlink" title="主机B配置"></a>主机B配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yum install -y iproute vnc qemu-kvm</span><br><span class="line"># 也需要安装openvswitch</span><br><span class="line">rpm -iv openvswitch-2.5.3-1.x86_64.rpm</span><br><span class="line"></span><br><span class="line">systemctl start openvswitch</span><br><span class="line">ovs-vsctl set interface gre1 type=gre options:remote_ip=192.168.10.1</span><br><span class="line"></span><br><span class="line">#从A复制脚本镜像到B主机</span><br><span class="line">scp /etc/if-* cirros-no_cloud-0.3.0-x86_64-disk.img root@192.168.153.142:/root/</span><br><span class="line"></span><br><span class="line">mv if-* /etc/</span><br><span class="line"></span><br><span class="line"># 启动虚拟机</span><br><span class="line">/usr/libexec/qemu-kvm -name &apos;vm3&apos; -m 128 -smp 1 -drive file=cirros-no_cloud-0.3.0-x86_64-disk.img,media=disk,if=virtio, -net nic,model=virtio,macaddr=52:56:00:00:00:61 -net tap,ifname=vif1.0,script=/etc/if-up,downscript=/etc/if-down --daemonize</span><br></pre></td></tr></table></figure><p>B主机虚拟机获取到A主机DHCP的地址</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gik4ubv1j30z50pu7e8.jpg" alt="enter description here"></p><p>VM2主机与VM3主机跨主机通信</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gikgy189j30y90prn6r.jpg" alt="enter description here"></p><p>在主机A ens37网卡抓包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# tcpdump -i ens37 -nn</span><br><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on ens37, link-type EN10MB (Ethernet), capture size 262144 bytes</span><br><span class="line">18:43:18.906672 IP 192.168.10.1 &gt; 192.168.10.2: GREv0, length 102: IP 10.0.4.210 &gt; 10.0.4.211: ICMP echo request, id 41984, seq 86, length 64</span><br><span class="line">18:43:18.907074 IP 192.168.10.2 &gt; 192.168.10.1: GREv0, length 102: IP 10.0.4.211 &gt; 10.0.4.210: ICMP echo reply, id 41984, seq 86, length 64</span><br></pre></td></tr></table></figure></p><p>可以看出IP报文被二次封装后发送….<br>至此<code>VM1`</code>VM2<code></code>VM3`可正常通信。</p><p>以上完成虚拟主机在宿主机主机之间的通信，虚拟主机与外网通信放到下一篇文章中<br><a href="https://nova-he.github.io/2017/10/24/OpenStack2/">openstack–网络环境实践(二)</a></p>]]></content>
      
      
      <categories>
          
          <category> OpenStack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenStack </tag>
            
            <tag> Openvswitch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memcached原理</title>
      <link href="/2017/10/16/memcached%E5%8E%9F%E7%90%86/"/>
      <url>/2017/10/16/memcached%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Memcached是一款开源的、高性能的、基于内存的<code>key-value</code>的分布式内存对象缓存系统，可应用各种需要缓存的场景，其主要目的是通过降低对数据库的访问来加速web应用程序。</p><a id="more"></a><h2 id="缓存方式"><a href="#缓存方式" class="headerlink" title="缓存方式"></a>缓存方式</h2><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjjtelmcj30ik0ft74r.jpg" alt="enter description here" title="缓存方式"></p><h2 id="主要特征"><a href="#主要特征" class="headerlink" title="主要特征"></a>主要特征</h2><ul><li>基于C/S架构，协议简单</li><li>基于libevent的事件处理</li><li>自主内存存储处理 </li><li>基于客户端的Memcached分布式</li></ul><p>本文则通过其主要特征认识mecached</p><h3 id="简单的底层协议"><a href="#简单的底层协议" class="headerlink" title="简单的底层协议"></a>简单的底层协议</h3><p>memcached基于C/S架构。客户端和 memcached的服务器通信并不使用复杂的XML等格式，而使用简单的基于文本行的协议。<br>因此，通过telnet也能在memcached上保存数据、取得数据。</p><p>通过telnet作为客户端与memcacehed服务器端通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ telnet localhost 11211</span><br><span class="line">Trying 127.0.0.1</span><br><span class="line">Connected to localhost.localdomain (127.0.0.1).</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">set foo 0 0 3     # 设置key </span><br><span class="line">bar               # 输入保存的数据</span><br><span class="line">STORED            # 结果保存成功</span><br><span class="line">get foo           # 获取key</span><br><span class="line">VALUE foo 0 3     # 成功取到数据</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><h3 id="事件处理方式"><a href="#事件处理方式" class="headerlink" title="事件处理方式"></a>事件处理方式</h3><p>memcached采用基于libevent的事件处理机制。<br>libevent库将Linux的epoll、BSD类操作系统的kqueue等事件处理功能封装成统一的跨平台的事件处理接口。即使对服务器的连接数增加，也能发挥O(1)的性能。Memcached使用libevent来进行网络并发连接的处理，能够保持在很大并发情况下，仍旧能够保持快速的响应能力。</p><h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p>为了提高性能，memcached中保存的数据都存储在memcached内置的内存存储空间中。memcached采用自主内存管理的方式，内存管理方式将直接决定其性能，我们将从两方面认识其内存管理方式：</p><ul><li>数据的存储方式 <code>Slab Allocation</code></li><li>数据过期方式<code>Lazy Expiration</code> + <code>LRU</code> </li></ul><p><strong>数据存储</strong><br>内存的碎片化<br>当我们使用C语言或者其他语言进行malloc，free等类似的命令操作内存的时候，在不断的申请和释放的过程中，形成了一些很小的内存片段，我们无法继续的利用，那这种空闲，无法继续利用内存的情况，我们称之为内存的碎片化。</p><p>memcached使用slab allocator的机制来管理内存<br>Slab Allocator 的基本原理是按照预先规定的大小，将分配的内存分割成数个<code>slab class</code>仓库。各个仓库切分成不同尺寸的小块（chunk）。<br>Slab Alloction 构造图</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gju11sxwj30bf08idg7.jpg" alt="enter description here" title="SlabAlloction构造图"></p><p>memcached根据收到的数据的大小，选择最合适数据大小的chunk组（slab class），在memcached中保存着slab class内空闲chunk的列表，根据列表选择空的chunk，然后将数据缓存其中</p><p>Slab Classes分配图</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjuckl1zj30bf08i0sr.jpg" alt="enter description here" title="Slab Classes分配图"></p><p>由于slab allocate机制中，分配的chunk的大小是固定的。因此，对于特定的item，可能更会造成内存的浪费<br>比如说：将100字节的数据缓存到122字节的chunk中，剩余的22个字节就浪费了</p><p> <img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjukfqkdj30be04uwee.jpg" alt="enter description here"></p><p>对于chunk空间的浪费问题，无法彻底的解决，只能修改参数<code>grow factor</code>（增长因子）。</p><p><strong>数据过期</strong><br>memcached采用<code>Lazy Expiration</code>+<code>LRU</code>相结合的方式保证内存空间的循环利用</p><ul><li>Lazy Expiration<br>  memcached内部不会监视记录是否过期，而是在get时查看记录的时间戳，检查记录是否过期。这种技术被称为lazy（惰性）expiration。因此，memcached不会在过期监视上耗费CPU时间。</li><li>LRU<br> memcached会优先使用已超时的记录的空间，但即使如此，也会发生追加新记录时空间不足的情况，此时就要使用名为 Least Recently Used Least Recently Used（LRU）机制来分配空间。顾名思义，这是删除<code>最近最少使用</code>的记录的机制。因此，当memcached的内存空间不足时，就从最近未被使用的记录中搜索，并将其空间分配给新的记录。从缓存的实用角度来看，该模型十分理想。 </li></ul><blockquote><p>LRU算法原理：当某个单元被请求时，单元内维护者一个计数器，通过计数器判断谁最近最少未使用。</p></blockquote><h3 id="通信分布式"><a href="#通信分布式" class="headerlink" title="通信分布式"></a>通信分布式</h3><p>memcached尽管是“分布式”缓存服务器，但服务器端并没有分布式功能。各个memcached不会互相通信以共享信息。那么，怎样进行分布式呢？这完全取决于客户端的实现。</p><p>通信过程：<br>当向memcached集群存入/取出key/value时，memcached客户端程序根据一定的算法计算存入哪台服务器，然后再把key/value值存到此服务器中。当需要读取时，客户端根据算法到指定的服务器读取即可。</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjm3ly67j30u30grgqs.jpg" alt="enter description here"></p><p><strong>常见的分布式缓存算法</strong></p><h4 id="取模法"><a href="#取模法" class="headerlink" title="取模法"></a>取模法</h4><p>先求得键做哈希计算，再除以服务器台数，根据余数确定存取服务器，就可得到下面的式子：<br><code>hash（key）%N</code></p><blockquote><p><code>key</code>  数据的键<br><code>hash()</code> hash的函数<br><code>N</code>     缓存服务器数量</p></blockquote><p>这种方法计算简单，但结果很容易受N的值影响，当服务器数量N增加或者减少的时候，原先的缓存数据定位几乎失效。<br>于是 人们提出了一致性hash算法，最终目的是实现在移除、添加一个memcached服务器时对已经存在的缓存数据的定位影响尽可能的降到最小。</p><h4 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h4><p>先算出memcached服务器的hash值<code>hash（node）</code>，并将其分布hash环上(0到2的32次方的圆)，然后用同样的方法算出存储数据的键的hash值<code>hash（key）</code>，并映射至hsah环上，当从数据映射到的位置开始顺时针查找，将数据保存到查找到的第一个服务器上，（如果超过2的32次方，依然找不到服务器，就将数据保存到第一台memcached服务器上）。如果添加了一台memcached服务器，只在圆上增加服务器的逆时针方向的第一台服务器上的键会受到影响。</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjlvcz67j30ee0c7abb.jpg" alt="enter description here"></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://docs.linuxtone.org/ebooks/NOSQL/memcached/memcached--%E9%BB%91%E5%A4%9C%E8%B7%AF%E4%BA%BA.pdf" target="_blank" rel="noopener">Memcached原理和使用详解</a><br><a href="http://blog.csdn.net/eric_sunah/article/details/51612316" target="_blank" rel="noopener">Memcache知识点梳理</a></p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Memcached </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化和复制</title>
      <link href="/2017/10/15/redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E5%A4%8D%E5%88%B6/"/>
      <url>/2017/10/15/redis%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E5%A4%8D%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Redis作为一个开源的、优秀的、基于内存的<code>key-value</code>缓存及持久化存储解决方案，同时也提供了复制功能，本文主要介绍Redis的持久化功能和复制原理。</p><h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><p>redis数据的操作在内存中完成，一旦服务器进程退出，数据就会丢失。为了解决这个问题，可将内存中的数据保存到磁盘中，避免数据的丢失，在重启服务时加载数据，实现持久化。Redis提供了两种持久化的方案：</p><ul><li><code>RDB</code>持久化 以指定的时间间隔执行数据集的即时点(point-in-time)快照。</li><li><code>AOF</code>持久化 在服务端记录每次收到的写操作，在服务器启动时会重放，以重建原始数据集。</li></ul><a id="more"></a><h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB持久化通过类似周期性快照的方式<code>snapshot</code>，写操作存储为二进制文件。</p><h4 id="RDB的创建与载入"><a href="#RDB的创建与载入" class="headerlink" title="RDB的创建与载入"></a>RDB的创建与载入</h4><p>客户端显式使用<code>save</code>或<code>bgsave</code>命令启动快照保存机制：</p><ul><li><code>SAVE</code>(同步) 阻塞redis的服务器进程，直到RDB文件被创建完毕。</li><li><code>BGSAVE</code>(异步) 派生(fork)一个子进程来创建新的RDB文件，记录接收到BGSAVE当时的数据库状态，进   程继续处理接收到的命令，子进程完成文件的创建之后，会发送信号给父进程，而与此同时，父进程处理     命令的同时，通过轮询来接收子进程的信号。</li></ul><h4 id="自动保存间隔"><a href="#自动保存间隔" class="headerlink" title="自动保存间隔"></a>自动保存间隔</h4><p><code>BGSAVE</code>可以在不阻塞主进程的情况下完成数据的备份。可以通过<code>redis.conf</code>中设置多个自动保存条件，只要有一个条件被满足，服务器就会执行<code>BGSAVE</code>命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># redis默认配置策略，需要关闭时配置：SAVE &quot;&quot;</span><br><span class="line">SAVE 900 1      # 服务器在900秒之内被修改了1次</span><br><span class="line">SAVE 300 10     # 服务器在300秒之内被修改了10次</span><br><span class="line">SAVE 60 10000   # 服务器在60秒之内被修改了10000次</span><br><span class="line"></span><br><span class="line"># 其他选项</span><br><span class="line">stop-writes-on-bgsave-error yes  # 在数据同步有错时是否通知操作</span><br><span class="line">rdbcompression yes               # 数据是否压缩</span><br><span class="line">rdbchecksum yes                  # 是否校验</span><br><span class="line">dbfilename dump.rdb              # 文件名称</span><br><span class="line">dir /var/lib/redis             # 文件存放路径</span><br></pre></td></tr></table></figure></p><p>RDB文件的载入一般情况是自动的，redis服务器启动的时候，redis服务器再启动的时候如果检测到RDB文件的存在，那么redis会自动载入这个文件。</p><p>如果服务器开启了AOF持久化，那么服务器会优先使用AOF文件来还原数据库状态。</p><p>RDB是通过保存键值对来记录数据库状态的，采用<code>copy on write</code>的模式，每次都是全量的备份。</p><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>每次Redis收到修改数据集的命令，将会被追加到 AOF文件中。当你重启 Redis 的时候，就会重放(re-play)AOF文件来重建数据库状态。</p><p>可以想象，写操作不断执行的时候 AOF文件会越来越大。例如，如果你增加一个计数器 100 次，你的数据集里只会有一个键存储这最终值，但是却有 100 条记录在 AOF 中。其中 99 条记录在重建当前状态时是不需要的。<br>于是 Redis 支持一个<code>日志重写</code>的机制：在后台重建AOF而不影响服务客户端。每当你发送BGREWRITEAOF时，Redis将会写入一个新的AOF文件，包含重建当前内存中数据集所需的最短命令序列(Redis 2.2的AOF，需要不时的运行 BGREWRITEAOF 命令)。</p><p><code>日志重写</code>采用了和快照一样的写时复制机制。过程如下：</p><ul><li>Redis调用fork()创建子进程。</li><li>子进程开始向一个临时文件中写 AOF。</li><li>父进程在一个内存缓冲区中积累新的变更(同时将新的变更写入旧的 AOF 文件，所以即使重写失败我们也安全)。</li><li>当子进程完成重写文件，父进程收到一个信号，追加内存缓冲区到子进程创建的文件末尾。</li><li>Redis 自动重命名旧文件为新的AOF文件，然后开始追加新数据到新文件。</li></ul><h4 id="相关选项"><a href="#相关选项" class="headerlink" title="相关选项"></a>相关选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#AOF 和 RDB 持久化方式可以同时启动并且无冲突。  </span><br><span class="line">#如果AOF开启，启动redis时会优先加载AOF文件，这些文件能够提供更好的保证。 </span><br><span class="line">appendonly yes</span><br><span class="line"></span><br><span class="line"># 只增文件的文件名称。（默认是appendonly.aof）  </span><br><span class="line"># appendfilename appendonly.aof </span><br><span class="line"></span><br><span class="line">#redis支持三种不同的写入方式：  </span><br><span class="line">#  </span><br><span class="line"># no:不调用，之等待操作系统来清空缓冲区当操作系统要输出数据时。很快。  </span><br><span class="line"># always: 每次更新数据都写入仅增日志文件。慢，但是最安全。</span><br><span class="line"># everysec: 每秒调用一次，折中方案。</span><br><span class="line">appendfsync everysec  </span><br><span class="line"></span><br><span class="line"># 设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入.官方文档建议如果你有特殊的情况可以配置为&apos;yes&apos;。但是配置为&apos;no&apos;是最为安全的选择。</span><br><span class="line">no-appendfsync-on-rewrite no  </span><br><span class="line"></span><br><span class="line"># 自动重写只增文件。  </span><br><span class="line"># redis可以自动盲从的调用‘BGREWRITEAOF’来重写日志文件，如果日志文件增长了指定的百分比。  </span><br><span class="line"># 当前AOF文件大小是上次日志重写得到AOF文件大小的二倍时，自动启动新的日志重写过程。</span><br><span class="line">auto-aof-rewrite-percentage 100  </span><br><span class="line"># 当前AOF文件启动新的日志重写过程的最小值，避免刚刚启动Reids时由于文件尺寸较小导致频繁的重写。</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br></pre></td></tr></table></figure><h3 id="AOF和RDB-的相互作用"><a href="#AOF和RDB-的相互作用" class="headerlink" title="AOF和RDB 的相互作用"></a>AOF和RDB 的相互作用</h3><p>Redis 2.4 及以后的版本中，不允许在 RDB 快照操作运行过程中触发 AOF 重写，也不允许在 AOF 重写运行过程中运行 BGSAVE。这防止了两个 Redis 后台进程同时对磁盘进行繁重的 IO 操作。当在快照运行的过程中，用户使用 BGREWRITEAOF 显式请求日志重写操作的话，服务器会答复一个 OK 状态码，告诉用户这个操作已经被安排调度，等到快照完成时开始重写。</p><p>Redis 在同时开启 AOF 和 RDB 的情况下重启，会使用 AOF 文件来重建原始数据集，因为通常 AOF 文件是保存数据最完整的。</p><hr><h2 id="redis复制"><a href="#redis复制" class="headerlink" title="redis复制"></a>redis复制</h2><p>复制技术使得数据库的读写操作可以分散在运行于不同CPU之上的独立服务器上，同时也实现数据冗余。<br>Redis 的复制 (replication) 是一种使用和配置起来非常简单的主从(master-slave)复制，允许 Redis 从服务器成为主服务器的精确副本。</p><h3 id="复制的实现"><a href="#复制的实现" class="headerlink" title="复制的实现"></a>复制的实现</h3><p>redis支持一台物理机启动多个服务以实现，本次实例将在一台物理机上实现：<br>启动master实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># master节点</span><br><span class="line">/usr/bin/redis-server --port 8000 &amp;</span><br><span class="line"></span><br><span class="line"># slave 节点</span><br><span class="line">/usr/bin/redis-server --port 8001 --slaveof 127.0.0.1 8000 &amp;</span><br><span class="line">/usr/bin/redis-server --port 8002 --slaveof 127.0.0.1 8000 &amp;</span><br><span class="line">/usr/bin/redis-server --port 8003 --slaveof 127.0.0.1 8000 &amp;</span><br><span class="line"></span><br><span class="line"># 查看端口</span><br><span class="line">ss -tnl </span><br><span class="line"></span><br><span class="line">LISTEN      0      128       *:8000                  *:*                  </span><br><span class="line">LISTEN      0      128       *:8001                  *:*                  </span><br><span class="line">LISTEN      0      128       *:8002                  *:*                  </span><br><span class="line">LISTEN      0      128       *:8003                  *:*</span><br></pre></td></tr></table></figure></p><p>这样，我们就成功的启动了四台Redis实例，master实例的服务端口为8000，R1、R2、R3的服务端口分别为8001、8002、8003，集群图如下：</p><p><img src="hhttps://ws1.sinaimg.cn/large/006v3NJegy1g1gk19dsu5j30hs0bomzi.jpg" alt="enter description here"></p><h3 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h3><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk1ghii0j30mi0jydjf.jpg" alt="enter description here"></p><p> 上图为Redis复制工作过程：</p><ul><li>slave向master发送sync命令。</li><li>master开启子进程来讲dataset写入rdb文件，同时将子进程完成之前接收到的写命令缓存起来。</li><li>子进程写完，父进程得知，开始将RDB文件发送给slave。</li><li>master发送完RDB文件，将缓存的命令也发给slave。</li><li>master增量的把写命令发给slave。</li></ul><p>同步是通过命令流完成的，和Redis的协议一样的格式。<br>用telnet 连接上Redis 的端口，然后发送 SYNC 命令，master会回应消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@node3 ~]# telnet  127.0.0.1 8000 </span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is &apos;^]&apos;.</span><br><span class="line">SYNC            # 发送SYNC命令</span><br><span class="line">$77</span><br><span class="line">REDIS0007redis-ver3.2.10</span><br><span class="line">redis-bits????e?Lused-mem?X?\eRXshell*1</span><br><span class="line">$4</span><br><span class="line">PING</span><br></pre></td></tr></table></figure></p><h3 id="部分重同步"><a href="#部分重同步" class="headerlink" title="部分重同步"></a>部分重同步</h3><p>当主从链路由于某些原因断开时，从服务器可以自动重连。如果主服务器收到多个并发的从服务器的同步请求，只会执行一个后台保存来服务所有从服务器。<br>从 Redis 2.8 开始，在复制链接断开后，在从服务器再次连接主服务器时可以继续复制过程，而不需要一次完整的重同步。</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk1od2p7j30xc0h2wjj.jpg" alt="enter description here"></p><p>master除了备份RDB文件之外还会维护者一个环形队列，以及环形队列的写索引和slave同步的全局offset，环形队列用于存储最新的操作数据，当slave和maste断开重连之后，会把slave维护的offset，也就是上一次同步到哪里的这个值告诉master，同时会告诉master上次和当前slave连接的master的runid，满足下面两个条件，Redis不会全量复制：</p><ul><li>slave传递的run id和master的run id一致。</li><li>master在环形队列上可以找到对应的offset值。</li></ul><p>复制是由psync命令实现的，slave可以通过psync命令来让Redis进行增量复制，当然最终是否能够增量复制取决于环形队列的大小和slave的断线时间长短和重连的这个master是否是之前的master。</p><p>配置相关参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">repl-backlog-size 1mb      # 环形队列大小</span><br><span class="line">repl-backlog-ttl 3600      # 没有slave需要同步的时候，多久可以释放环形队列</span><br><span class="line">repo-diskless-sync no      # 否开启Diskless Replication(免持久化)的开关配置</span><br><span class="line">repl-diskless-sync-delay 5 # 指定复制开始的时间延迟</span><br></pre></td></tr></table></figure></p><h3 id="从服务器只读"><a href="#从服务器只读" class="headerlink" title="从服务器只读"></a>从服务器只读</h3><p>从 Redis 2.6 开始，从服务器支持默认开启的只读模式。这个行为由 redis.conf 文件中的 slave-read-only 选项控制，可以在运行时使用 CONFIG SET 来开启和关闭。<br>这种特性不能意味着暴露从服务器到互联网，因为诸如 DEBUG 和 CONFIG 这样的管理命令等仍可用。但是可以通过在 redis.conf 中使用 rename-command 指令来禁止命令。<br>这些写入的数据会在从服务器和主服务器重同步时，或者从服务器重启时被丢弃，还是有一些存储一些短暂的数据到可写的从服务器的合理场景。<br>比如：主服务器故障，需要其他节点作为主服务器时。</p><h3 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h3><p>从 Redis 2.8 开始，可以设置 Redis 主服务器在当前至少拥有 N 个从服务器的连接的情况下，才能接受写请求。<br>和MySQL复制策略有点类似，Redis复制本身是异步的，但也提供了半同步的复制策略，半同步复制策略在Redis复制中的语义是这样的：</p><ul><li>Redis 从服务器每秒种 ping 主服务器，上报处理完的复制流的数据量。</li><li>Redis 主服务器记录上一次从每一个从服务收到 ping 的时间。</li><li>用户可以配置最小从服务器数量，每台从服务器拥有一个不大于最大秒数的滞后(lag)。</li></ul><p>这个特性有两个配置参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write &lt;number of slaves&gt;   # N的数量</span><br><span class="line">min-slaves-max-lag &lt;number of seconds&gt;   # 指定时间间隔</span><br></pre></td></tr></table></figure></p><p>如果有至少<code>N</code>个小于<code>M</code>秒滞后的从服务器，写请求才会被接受。<br>你可能会认为这个像 <code>CAP</code> 理论中较宽松版本的<code>C</code>，不能保证指定写的一致性，但是至少数据丢失的时间窗口被限制在一个指定的秒数内。<br>如果条件不满足，主服务器会返回一个错误，并且不会接受写请求。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>马哥运维笔记<br><a href="http://blog.jobbole.com/101678/" target="_blank" rel="noopener">浅析 Redis 复制</a><br><a href="https://redis.io/topics/persistence" target="_blank" rel="noopener">redis官方文档</a></p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB副本集复制和分片</title>
      <link href="/2017/10/14/MongoDB%E5%89%AF%E6%9C%AC%E9%9B%86%E5%A4%8D%E5%88%B6%E5%92%8C%E5%88%86%E7%89%87/"/>
      <url>/2017/10/14/MongoDB%E5%89%AF%E6%9C%AC%E9%9B%86%E5%A4%8D%E5%88%B6%E5%92%8C%E5%88%86%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>MongoDB是一个开源非关系文档型数据库。在MongoDB中的每一个记录是一个文档，文档类似于JSON对象，它是一个由字段和值对组成的数据结构。</p><p>类似json的文档存储</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjvjxhi5j30fu04q0sz.jpg" alt="类似json的文档存储"><br><a id="more"></a><br>MongoDB出现解决了传统关系型数据库对海量数据的处理难题。以传统的MySQL为代表的关系型数据库，事务保证操作和数据的可靠性，但同时也限制了数据的扩展性和数据库海量数据的处理能力。MongoDB的数据库不支持事务，这使它突破了关系型数据库的局限性，得到了良好的扩展性。在实现上MongoDB借鉴了MySQL，在操作方式上和工作模式与MySQL类似。</p><p>以下通过<code>MongoDB副本集复制和分片</code>，认识其对海量数据的处理和其原理：</p><h2 id="MongoDB副本集复制"><a href="#MongoDB副本集复制" class="headerlink" title="MongoDB副本集复制"></a>MongoDB副本集复制</h2><p>MongoDB在数据冗余方面提供了两种方案：</p><ul><li><code>master/slave</code> 主从复制</li><li><code>replica set</code>  副本集复制</li></ul><p><code>master/slave</code>是和MySQL类似的一种复制方式，master端启动一个I/O线程用于向slave端同步写日志文件，slave端启动两个线程，一个IO线程把日志文件记录在slave节点的中继日志中，SQL线程把中继日志进行回放完成备份，只是MySQL中的<code>binlog</code>在MongoDB叫做<code>OpLog</code>日志文件。</p><p>这种复制方式最大的弊端在于：主节点成为最大的单点所在，可能有人会说，给主节点做高可用，随之而来是就是一堆问题：</p><ul><li>两个主节点数据不应该也一样吗？两个主节点又互为单点所在</li><li>当主节点A的宕机，A中的事务没有执行完，B中的数据怎么回滚？双主节点事务难以同步</li></ul><p>可以看出，事务在某些不必要的场景，反而带来很多问题，于是MongoDB摆脱了事务的限制，提出了第二种方式<code>replica set</code>：</p><p>副本集复制过程</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjvs80r3j30dw0bd3zs.jpg" alt="enter description here"></p><p>工作方式如下：<br> 在MongoDB中一个副本集即为服务于同一数据集的多个MongoDB实例，其中一个为主节点<code>Primary</code>，其余的都为从节点<code>Secondary</code>（主节点上能够完成读写操作，从节点仅能用于读操作）。主节点记录所有改变数据库状态的操作，将这些记录保存在oplog中，oplog存储在local数据库，各个从节点通过此oplog来复制数据并应用于本地，保持本地的数据与主节点的一致。oplog具有幂等性（无论执行几次其结果一致），比mysql的二进制日志更高效可靠。<br>集群中的各节点通过传递心跳信息(默认每2秒传递一次)来检测各自的健康状况。当主节点故障时多个从节点会触发一次新的选举操作，并选举其中的一个成为新的主节点（通常谁的优先级更高，谁就是新的主节点）。<br>各个从节点传递心跳信</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjw0yz8aj30jg07dwfw.jpg" alt="各个从节点传递心跳信息"><br>没有事务的限制，当主节点宕机时，每个从节点都可以作为主节点。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>实验环境</p><table><thead><tr><th>主机</th><th>IP地址</th></tr></thead><tbody><tr><td>Primary</td><td>192.168.80.5</td></tr><tr><td>Secondary</td><td>192.168.80.8</td></tr><tr><td>Secondary</td><td>192.168.80.9</td></tr></tbody></table><p>其配置较为简单，分为以下几个步骤：</p><ul><li><p>安装配置MongoDB服务器端和客户端</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mongodb-server mongodb</span><br></pre></td></tr></table></figure><p> 配置文件信息：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@mongo1 ~]# vim /etc/mongod.conf </span><br><span class="line"></span><br><span class="line">logpath=/var/log/mongodb/mongod.log </span><br><span class="line">logappend=true </span><br><span class="line">fork=true</span><br><span class="line">dbpath=/data/mongodb</span><br><span class="line">pidfilepath=/var/run/mongodb/mongod.pid</span><br><span class="line">bind_ip=0.0.0.0     # 服务监听的地址</span><br><span class="line">httpinterface=true</span><br><span class="line">rest=true</span><br><span class="line">replSet=rs0         # 指定了副本集名称，多个副本集用于区别</span><br><span class="line">replIndexPrefetch = _id_only    #指定副本集的索引预取，如果有预取功能可以让复制过程更为高效，</span><br><span class="line"># 有3个值none，_id_only，all。</span><br><span class="line"># none：不预取任何索引，</span><br><span class="line"># _id_only：预取ID索引，</span><br><span class="line"># all：预取所有索引。</span><br></pre></td></tr></table></figure></li><li><p>创建数据目录启动服务</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@mongo1 ~]# mkdir -pv /data/mongodb</span><br><span class="line"></span><br><span class="line">mkdir: created directory `/mongodb&apos;</span><br><span class="line">mkdir: created directory `/data/mongodb&apos;</span><br><span class="line">[root@mongo1 ~]# chown -R mongod.mongod /data/mongodb</span><br><span class="line"> </span><br><span class="line">[root@mongo1 ~]# systemctl start mongod # 在每一个节点启动服务</span><br></pre></td></tr></table></figure></li><li><p>配置添加集群成员</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">[root@mongo1 ~]# mongo --host 192.168.1.132</span><br><span class="line">MongoDB shell version: 2.6.5</span><br><span class="line">connecting to: 192.168.1.132:27017/test</span><br><span class="line">&gt; rs.status()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;startupStatus&quot; : 3,</span><br><span class="line">    &quot;info&quot; : &quot;run rs.initiate(...) if not yet done for the set&quot;,</span><br><span class="line">    &quot;ok&quot; : 0,</span><br><span class="line">    &quot;errmsg&quot; : &quot;can&apos;t get local.system.replset config from self or any seed (EMPTYCONFIG)&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;rs.initiate()  #主节点初始化</span><br><span class="line">&gt;rs.status()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">&quot;set&quot; : &quot;testSet&quot;,</span><br><span class="line">&quot;date&quot; : ISODate(&quot;2017-10-13T08:25:57Z&quot;),</span><br><span class="line">&quot;myState&quot; : 1,</span><br><span class="line">&quot;members&quot; : [</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : 0,</span><br><span class="line">&quot;name&quot; : &quot;www.dearecho.me:27017&quot;,</span><br><span class="line">&quot;health&quot; : 1,</span><br><span class="line">&quot;state&quot; : 1,</span><br><span class="line">&quot;stateStr&quot; : &quot;PRIMARY&quot;,</span><br><span class="line">&quot;uptime&quot; : 234,</span><br><span class="line">&quot;optime&quot; : Timestamp(1507883148, 1),</span><br><span class="line">&quot;optimeDate&quot; : ISODate(&quot;2017-10-13T08:25:48Z&quot;),</span><br><span class="line">&quot;electionTime&quot; : Timestamp(1507883149, 1),</span><br><span class="line">&quot;electionDate&quot; : ISODate(&quot;2017-10-13T08:25:49Z&quot;),</span><br><span class="line">&quot;self&quot; : true</span><br><span class="line">&#125;</span><br><span class="line">],</span><br><span class="line">&quot;ok&quot; : 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs0:PRIMARY&gt; rs.add(&quot;192.168.80.8&quot;) # 发现前面的标识变为了Primary，添加从节点</span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line">rs0:PRIMARY&gt; rs.add(&quot;192.168.80.9&quot;)</span><br><span class="line">&#123; &quot;ok&quot; : 1 &#125;</span><br><span class="line"></span><br><span class="line">在创建副本集时，有3种方式：</span><br><span class="line">db.runCommand( &#123; replSetInitiate : &lt;config_object&gt; &#125; )</span><br><span class="line">rs.initiate(&lt;config_object&gt;)</span><br><span class="line">rs.initiate()      #先在其中一个节点上初始化，再通过rs.add添加另外的节点</span><br><span class="line">这里采用的是第一种方式。</span><br></pre></td></tr></table></figure></li></ul><ul><li>查看各节点信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&gt; rs.status()</span><br><span class="line"> &#123;</span><br><span class="line">     &quot;set&quot; : &quot;rs0&quot;,</span><br><span class="line">     &quot;date&quot; : ISODate(&quot;2015-09-04T23:02:13Z&quot;),</span><br><span class="line">     &quot;myState&quot; : 1,</span><br><span class="line">     &quot;members&quot; : [                                                       #显示副本集的所有成员信息</span><br><span class="line">         &#123;</span><br><span class="line">             &quot;_id&quot; : 0,                                          #节点的标识符</span><br><span class="line">             &quot;name&quot; : &quot;192.168.80.5:27017&quot;,                      #节点名称    </span><br><span class="line">             &quot;health&quot; : 1,                                       #节点的健康状态            </span><br><span class="line">             &quot;state&quot; : 1,                                                                                </span><br><span class="line">             &quot;stateStr&quot; : &quot;PRIMARY&quot;,                             #该节点为主节点                                </span><br><span class="line">             &quot;uptime&quot; : 1750,                                    #运行时长                   </span><br><span class="line"> &quot;optime&quot; : Timestamp(1507898695, 173),              #oplog最后一次操作的时间戳</span><br><span class="line"> &quot;optimeDate&quot; : ISODate(&quot;2017-10-13T12:44:55Z&quot;),</span><br><span class="line"> &quot;lastHeartbeat&quot; : ISODate(&quot;2017-10-13T12:53:19Z&quot;),</span><br><span class="line"> &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-10-13T12:53:19Z&quot;),</span><br><span class="line"> &quot;pingMs&quot; : 0,</span><br><span class="line"> &quot;electionTime&quot; : Timestamp(1507899169, 1), #选举日期                                  </span><br><span class="line">             &quot;self&quot; : true                                       #表示是否为当前节点</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">             </span><br><span class="line">             &quot;_id&quot; : 1,                                          #节点的标识符</span><br><span class="line">             &quot;name&quot; : &quot;192.168.80.8:27017&quot;,                      #节点名称    </span><br><span class="line">             &quot;health&quot; : 1,                                       #节点的健康状态            </span><br><span class="line">             &quot;state&quot; : 1,                                                                                </span><br><span class="line">             &quot;stateStr&quot; : &quot;SECONDARY&quot;,                            #从节点                                </span><br><span class="line">             &quot;uptime&quot; : 1750,                                    #运行时长                   </span><br><span class="line"> &quot;optime&quot; : Timestamp(1507898695, 173),              #oplog最后一次操作的时间戳</span><br><span class="line"> &quot;optimeDate&quot; : ISODate(&quot;2017-10-13T12:44:55Z&quot;),</span><br><span class="line"> &quot;lastHeartbeat&quot; : ISODate(&quot;2017-10-13T12:53:19Z&quot;),</span><br><span class="line"> &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-10-13T12:53:19Z&quot;),</span><br><span class="line"> &quot;pingMs&quot; : 0,</span><br><span class="line"> &quot;syncingTo&quot; : &quot;192.168.80.5:27017&quot;                  #指向的主节点</span><br><span class="line">         &#125;,</span><br><span class="line">         &#123;</span><br><span class="line">             &quot;_id&quot; : 2,                                         </span><br><span class="line">             &quot;name&quot; : &quot;192.168.80.9:27017&quot;,                         </span><br><span class="line">             &quot;health&quot; : 1,                                                  </span><br><span class="line">             &quot;state&quot; : 1,                                                                                </span><br><span class="line">             &quot;stateStr&quot; : &quot;SECONDARY&quot;,                            #从节点                                </span><br><span class="line">             &quot;uptime&quot; : 1750,                                                       </span><br><span class="line"> &quot;optime&quot; : Timestamp(1507898695, 173),              </span><br><span class="line"> &quot;optimeDate&quot; : ISODate(&quot;2017-10-13T12:44:55Z&quot;),</span><br><span class="line"> &quot;lastHeartbeat&quot; : ISODate(&quot;2017-10-13T12:53:19Z&quot;),</span><br><span class="line"> &quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-10-13T12:53:19Z&quot;),</span><br><span class="line"> &quot;pingMs&quot; : 0,</span><br><span class="line"> &quot;syncingTo&quot; : &quot;192.168.80.5:27017&quot;                  #指向的主节点</span><br><span class="line">         &#125;</span><br><span class="line">     ],</span><br><span class="line">     &quot;ok&quot; : 1</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在主节点添加测试数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rs0:PRIMARY&gt; use student_db </span><br><span class="line">switched to db student_db</span><br><span class="line">rs0:PRIMARY&gt; for (i=1;i&lt;=100000;i++) db.students.insert(&#123;name:&quot;student&quot;+i,age:(i%120),address:&quot;china_nb&quot;&#125;);</span><br><span class="line">WriteResult(&#123; &quot;nInserted&quot; : 1 &#125;)</span><br></pre></td></tr></table></figure></p><p>在从节点查看数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rs0:SECONDARY&gt; show collections  </span><br><span class="line">2017-10-13T20:46:55.346+0800 error: &#123; &quot;$err&quot; : &quot;not master and slaveOk=false&quot;, &quot;code&quot; : 13435 &#125; at src/mongo/shell/query.js:131</span><br><span class="line"></span><br><span class="line">rs0:SECONDARY&gt; rs.slaveOk()  # 需启用从节点才可查看</span><br><span class="line">rs0:SECONDARY&gt; db.students.findOne()</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : ObjectId(&quot;59e0b54660703b86d071762f&quot;),</span><br><span class="line">&quot;name&quot; : &quot;student1&quot;,</span><br><span class="line">&quot;age&quot; : 1,</span><br><span class="line">&quot;address&quot; : &quot;china_nb&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主节点修改优先级<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">rs0:PRIMARY&gt; cfg = rs.config()</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : &quot;test&quot;,</span><br><span class="line">&quot;version&quot; : 3,</span><br><span class="line">&quot;members&quot; : [</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : 0,</span><br><span class="line">&quot;host&quot; : &quot;192.168.80.5:27017&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : 1,</span><br><span class="line">&quot;host&quot; : &quot;192.168.80.8:27017&quot;</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : 2,</span><br><span class="line">&quot;host&quot; : &quot;192.168.80.9:27017&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">rs0:PRIMARY&gt; cfg.members[1].priority=2   # 设置第二个节点优先级为2</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line">rs0:PRIMARY&gt; rs.reconfig(cfg)</span><br><span class="line">2017-10-13T21:13:01.255+0800 DBClientCursor::init call() failed</span><br><span class="line">2017-10-13T21:13:01.269+0800 trying reconnect to 127.0.0.1:27017 (127.0.0.1) failed</span><br><span class="line">2017-10-13T21:13:01.282+0800 reconnect 127.0.0.1:27017 (127.0.0.1) ok</span><br><span class="line">reconnected to server after rs command (which is normal)</span><br></pre></td></tr></table></figure></p><p>在<code>192.168.80.8</code>查看状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">rs0:PRIMARY&gt; db.printReplicationInfo()</span><br><span class="line">configured oplog size:   990MB</span><br><span class="line">log length start to end: 1098secs (0.31hrs)</span><br><span class="line">oplog first event time:  Fri Oct 13 2017 20:26:37 GMT+0800 (CST)</span><br><span class="line">oplog last event time:   Fri Oct 13 2017 20:44:55 GMT+0800 (CST)</span><br><span class="line">now:                     Fri Oct 13 2017 20:56:23 GMT+0800 (CST)</span><br><span class="line"></span><br><span class="line">rs.status()</span><br><span class="line">&#123;</span><br><span class="line">&quot;_id&quot; : 1,                  #节点2</span><br><span class="line">&quot;name&quot; : &quot;192.168.80.8:27017&quot;,</span><br><span class="line">&quot;health&quot; : 1,</span><br><span class="line">&quot;state&quot; : 1,</span><br><span class="line">&quot;stateStr&quot; : &quot;PRIMARY&quot;,     #已抢占为主节点</span><br><span class="line">&quot;uptime&quot; : 1602,</span><br><span class="line">&quot;optime&quot; : Timestamp(1507898695, 173),</span><br><span class="line">&quot;optimeDate&quot; : ISODate(&quot;2017-10-13T12:44:55Z&quot;),</span><br><span class="line">&quot;lastHeartbeat&quot; : ISODate(&quot;2017-10-13T12:53:19Z&quot;),</span><br><span class="line">&quot;lastHeartbeatRecv&quot; : ISODate(&quot;2017-10-13T12:53:19Z&quot;),</span><br><span class="line">&quot;pingMs&quot; : 0,</span><br><span class="line">&quot;electionTime&quot; : Timestamp(1507899169, 1),</span><br><span class="line">&quot;electionDate&quot; : ISODate(&quot;2017-10-13T12:52:49Z&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="MongoDB数据分片"><a href="#MongoDB数据分片" class="headerlink" title="MongoDB数据分片"></a>MongoDB数据分片</h2><p>在Mongodb里面存在另一种集群，就是分片技术,可以满足MongoDB数据量大量增长的需求。<br>当MongoDB存储海量的数据时，一台机器可能不足以存储数据，也可能不足以提供可接受的读写吞吐量。这时，我们就可以通过在多台机器上分割数据，使得数据库系统能存储和处理更多的数据。<br>MongoDB中使用分片集群结构分布：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjw8u9ywj30go0bf75x.jpg" alt="enter description here"><br>上图中主要有如下所述三个主要组件：</p><ul><li><code>Query Routers</code>前端路由，客户端由此接入，把客户端的请求路由到合适的shared上。</li><li><code>Config Server</code>实质为mongod实例存储了整个 ClusterMetadata，其中包括 chunk信息和索引信息。</li><li><code>Shard</code>存储实际的数据块，实际生产环境中一个shard server角色可由几台机器组个一个replica set承担，防止主机单点故障</li></ul><p>分片过程：<br>把表上以某个字段为例，字段创建为索引，索引当做分片的元数据，而后把大数据切割成一个一个的chunk，把每个chunk分配到每个shared。在整个业务运行过程中，重新均衡，chunk在每个节点上挪来挪去。</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><table><thead><tr><th>主机</th><th>IP</th></tr></thead><tbody><tr><td>Query Routers</td><td>192.168.80.5</td></tr><tr><td>Config server</td><td>192.168.80.7</td></tr><tr><td>Shared</td><td>192.168.80.8, 192.168.80.9</td></tr></tbody></table><p>实现步骤如下：</p><ul><li><p>配置各个节点<br> 配置<code>config server</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mongodb-server mongodb</span><br><span class="line"></span><br><span class="line">vim /etc/mongod.conf</span><br><span class="line">configsvr = true</span><br></pre></td></tr></table></figure><p> 启动其他节点：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">yum install -y mongodb-server mongodb</span><br><span class="line"></span><br><span class="line">mongos --configdb=192.168.80.7 --fork --logpath=/var/log/mongodb/mongo.log   # 启动Query Routers </span><br><span class="line"></span><br><span class="line">2017-10-14T10:32:40.251+0800 warning: running with 1 config server should be done only for testing purposes and is not recommended for production</span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 16035</span><br><span class="line">child process started successfully, parent exiting</span><br><span class="line"></span><br><span class="line">[root@node ~]# ss -tnl</span><br><span class="line">LISTEN      0      128     *:27017               *:*    # monogs监听在27017</span><br></pre></td></tr></table></figure></li></ul><p>​<br>    systemctl start mongod  # 启动shared<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- `Query Routers`配置</span><br></pre></td></tr></table></figure></p><pre><code># 节点加入`Shard`：mongos&gt; sh.addShard(&quot;192.168.80.8&quot;){ &quot;shardAdded&quot; : &quot;shard0000&quot;, &quot;ok&quot; : 1 }mongos&gt; sh.addShard(&quot;192.168.80.9&quot;){ &quot;shardAdded&quot; : &quot;shard0001&quot;, &quot;ok&quot; : 1 }mongos&gt; use student_db  # 创建数据库switched to db student_dbmongos&gt;  sh.enableSharding(&quot;student_db&quot;) # 数据库启用分片{ &quot;ok&quot; : 1 }mongos&gt; sh.shardCollection(&quot;student_db.students&quot;,{&quot;age&quot;:1}) # 创建collections，并指明索引{ &quot;collectionsharded&quot; : &quot;student_db.students&quot;, &quot;ok&quot; : 1 }   mongos&gt; sh.status()--- Sharding Status ---   sharding version: {    &quot;_id&quot; : 1,    &quot;version&quot; : 4,    &quot;minCompatibleVersion&quot; : 4,    &quot;currentVersion&quot; : 5,    &quot;clusterId&quot; : ObjectId(&quot;59e17748c68473e873f81bc7&quot;)}  shards:    {  &quot;_id&quot; : &quot;shard0000&quot;,  &quot;host&quot; : &quot;192.168.80.8:27017&quot; }    {  &quot;_id&quot; : &quot;shard0001&quot;,  &quot;host&quot; : &quot;192.168.80.9:27017&quot; }  databases:    {  &quot;_id&quot; : &quot;admin&quot;,  &quot;partitioned&quot; : false,  &quot;primary&quot; : &quot;config&quot; }    {  &quot;_id&quot; : &quot;test&quot;,  &quot;partitioned&quot; : true,  &quot;primary&quot; : &quot;shard0001&quot; }    {  &quot;_id&quot; : &quot;student&quot;,  &quot;partitioned&quot; : false,  &quot;primary&quot; : &quot;shard0000&quot; }    {  &quot;_id&quot; : &quot;student_db&quot;,  &quot;partitioned&quot; : true,  &quot;primary&quot; : &quot;shard0000&quot; } #数据库分片已启用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 测试</span><br></pre></td></tr></table></figure>#插入数据mongos&gt; for (i=1;i&lt;=100000;i++) db.students.insert({name:&quot;student&quot;+i,age:(i%120),address:&quot;china_nb&quot;});mongos&gt;sh.status()  # 查看数据库分片状态        student_db.students        shard key: { &quot;age&quot; : 1 }        chunks:                 shard0000    2  # 数据被分布在每一个shared上            shard0001    1        { &quot;age&quot; : { &quot;$minKey&quot; : 1 } } --&gt;&gt; { &quot;age&quot; : 1 } on : shard0001 Timestamp(2, 0)         { &quot;age&quot; : 1 } --&gt;&gt; { &quot;age&quot; : 119 } on : shard0000 Timestamp(2, 2)         { &quot;age&quot; : 119 } --&gt;&gt; { &quot;age&quot; : { &quot;$maxKey&quot; : 1 } } on : shard0000 Timestamp3, 3) ```</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Mongodb在丢弃了关系型数据库一些局限性：<code>事务</code> <code>关系</code>。同时采用文档形式对数据的存储，加大数据存储的同时加快数据的查询效率。此外Mongodb还提供完备的HA解决方案和分片的分布式策略。在不依赖于事务的大数据场景中，让其作为大数据处理有效的解决方案之一。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.runoob.com/mongodb/mongodb-replication.html" target="_blank" rel="noopener">MongoDB 复制（副本集）</a><br><a href="https://www.google.com/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=6&amp;cad=rja&amp;uact=8&amp;ved=0ahUKEwjk4brO8fPWAhUFMGMKHVoBCM8QFghTMAU&amp;url=http%3A%2F%2Fwiki.jikexueyuan.com%2Fproject%2Fmongodb%2Fmongodb-sharding.html&amp;usg=AOvVaw0pSfSozIUpuGl6grA0Ahui" target="_blank" rel="noopener">分片- Mongodb 教程- 极客学院Wiki</a></p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NoSQL </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Socket 编程</title>
      <link href="/2017/09/23/Python_Socket/"/>
      <url>/2017/09/23/Python_Socket/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-Socket-编程"><a href="#Python-Socket-编程" class="headerlink" title="Python Socket 编程"></a>Python Socket 编程</h1><h3 id="Socket-基本概念"><a href="#Socket-基本概念" class="headerlink" title="Socket 基本概念"></a>Socket 基本概念</h3><p>Socket 是对 TCP/IP 协议族的一种封装，是应用层与TCP/IP协议族通信的中间软件抽象层。从设计模式的角度看来，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><p>Socket 还可以认为是一种网络间不同计算机上的进程通信的一种方法，利用三元组（ip地址，协议，端口）就可以唯一标识网络中的进程，网络中的进程通信可以利用这个标志与其它进程进行交互。</p><p>Socket 起源于 Unix ，Unix/Linux 基本哲学之一就是“一切皆文件”，都可以用<code>打开(open)</code> -–&gt; <code>读写(write/read)</code> -–&gt; <code>关闭(close)</code>模式来进行操作。因此 Socket 也被处理为一种特殊的文件。</p><a id="more"></a><h3 id="Socket-编程思想"><a href="#Socket-编程思想" class="headerlink" title="Socket 编程思想"></a>Socket 编程思想</h3><p><strong>TCP 服务器</strong><br>1、创建套接字，绑定套接字到本地IP与端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.bind()</span><br></pre></td></tr></table></figure></p><p>2、开始监听链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.listen()</span><br></pre></td></tr></table></figure><p>3、进入循环，不断接受客户端的链接请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">While True:</span><br><span class="line">    s.accept()</span><br></pre></td></tr></table></figure><p>4、接收客户端传来的数据，并且发送给对方发送数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.sendall()</span><br></pre></td></tr></table></figure><p>5、传输完毕后，关闭套接字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.close()</span><br></pre></td></tr></table></figure><p><strong>TCP 客户端</strong><br>1、创建套接字并链接至远端地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect()</span><br></pre></td></tr></table></figure><p>2、链接后发送数据和接收数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.sendall()</span><br><span class="line">s.recv()</span><br></pre></td></tr></table></figure></p><p>3、传输完毕后，关闭套接字</p><h3 id="Socket-编程原理图"><a href="#Socket-编程原理图" class="headerlink" title="Socket 编程原理图"></a>Socket 编程原理图</h3><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjx1unqrj30ld0kz75x.jpg" alt="enter description here"></p><h3 id="Socket-编程实践之服务器端代码"><a href="#Socket-编程实践之服务器端代码" class="headerlink" title="Socket 编程实践之服务器端代码"></a>Socket 编程实践之服务器端代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python</span></span><br><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">8001</span></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.bind((HOST, PORT))</span><br><span class="line">s.listen()</span><br><span class="line">print(<span class="string">"The Server is listening %s:%s"</span>%(HOST,PORT))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#无限循环等待用户连接</span></span><br><span class="line">    conn,addr = s.accept()</span><br><span class="line">    print(<span class="string">"connected by "</span>,addr)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#无限循环接收用户消息</span></span><br><span class="line">        data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">        print(<span class="string">"client&gt;"</span>,data.decode())</span><br><span class="line">        msg = <span class="string">'Server have received your msg'</span></span><br><span class="line">        conn.send(msg.encode())</span><br><span class="line"></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure><h3 id="Socket-编程实践之客户端代码"><a href="#Socket-编程实践之客户端代码" class="headerlink" title="Socket 编程实践之客户端代码"></a>Socket 编程实践之客户端代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!usr/bin/python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">'127.0.0.1'</span></span><br><span class="line">PORT = <span class="number">8001</span></span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">s.connect((HOST,PORT))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = input(<span class="string">"please you msg:"</span>)</span><br><span class="line">    s.send(msg.encode())</span><br><span class="line">    data = s.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data.decode())</span><br></pre></td></tr></table></figure><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li>pyhton3中，数据在网络中传输时，因采用byte类型传输，需data.enconde()，传输接收后转化deconde()<br>如图：</li></ul><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjx8rfg5j30n003xt8t.jpg" alt="enter description here"></p><ul><li>发送数据后，数据被分组发送需要，让接收端sleep()后接受，可全部接受数据</li><li>服务器需要两层循环</li></ul><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>Python 提供了两个基本的 socket 模块：</p><ul><li><code>Socket</code> 它提供了标准的BSD Socket API。</li><li><code>SocketServer</code> 它提供了服务器重心，可以简化网络服务器的开发。</li></ul><p>下面讲解下 Socket模块功能</p><h3 id="Socket-类型"><a href="#Socket-类型" class="headerlink" title="Socket 类型"></a>Socket 类型</h3><p>套接字格式：socket(family, type[,protocal]) 使用给定的套接族，套接字类型，协议编号（默认为0）来创建套接字</p><table><thead><tr><th>socket 类型</th><th>描述</th></tr></thead><tbody><tr><td>socket.AF_UNIX</td><td>用于同一台机器上的进程通信（既本机通信）</td></tr><tr><td>socket.AF_INET</td><td>用于服务器与服务器之间的网络通信</td></tr><tr><td>socket.AF_INET6</td><td>基于IPV6方式的服务器与服务器之间的网络通信</td></tr><tr><td>socket.SOCK_STREAM</td><td>基于TCP的流式socket通信</td></tr><tr><td>socket.SOCK_DGRAM</td><td>基于UDP的数据报式socket通信</td></tr><tr><td>socket.SOCK_RAW</td><td>原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次SOCK_RAW也可以处理特殊的IPV4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头</td></tr><tr><td>socket.SOCK_SEQPACKET</td><td>可靠的连续数据包服务</td></tr></tbody></table><p>创建TCP Socket：</p><pre>sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</pre><p>创建UDP Socket：</p><pre>sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</pre><h3 id="Socket-函数"><a href="#Socket-函数" class="headerlink" title="Socket 函数"></a>Socket 函数</h3><ul><li>TCP发送数据时，已建立好TCP链接，所以不需要指定地址，而UDP是面向无连接的，每次发送都需要指定发送给谁。</li><li>服务器与客户端不能直接发送列表，元素，字典等带有数据类型的格式，发送的内容必须是字符串数据。</li></ul><p><strong>服务器端 Socket 函数</strong></p><table><thead><tr><th>Socket 函数</th><th>描述</th></tr></thead><tbody><tr><td>s.bind(address)</td><td>将套接字绑定到地址，在AF_INET下，以tuple(host, port)的方式传入，如s.bind((host, port))</td></tr><tr><td>s.listen(backlog)</td><td>开始监听TCP传入连接，backlog指定在拒绝链接前，操作系统可以挂起的最大连接数，该值最少为1，大部分应用程序设为5就够用了</td></tr><tr><td>s.accpet()</td><td>接受TCP链接并返回（conn, address），其中conn是新的套接字对象，可以用来接收和发送数据，address是链接客户端的地址。</td></tr></tbody></table><p><strong>客户端 Socket 函数</strong></p><table><thead><tr><th>Socket 函数</th><th>描述</th></tr></thead><tbody><tr><td>s.connect(address)</td><td>链接到address处的套接字，一般address的格式为tuple(host, port)，如果链接出错，则返回socket.error错误</td></tr><tr><td>s.connect_ex(address)</td><td>功能与s.connect(address)相同，但成功返回0，失败返回errno的值</td></tr></tbody></table><p><strong>公共 Socket 函数</strong></p><table><thead><tr><th>Socket 函数</th><th>描述</th></tr></thead><tbody><tr><td>s.recv(bufsize[, flag])</td><td>接受TCP套接字的数据，数据以字符串形式返回，buffsize指定要接受的最大数据量，flag提供有关消息的其他信息，通常可以忽略</td></tr><tr><td>s.send(string[, flag])</td><td>发送TCP数据，将字符串中的数据发送到链接的套接字，返回值是要发送的字节数量，该数量可能小于string的字节大小</td></tr><tr><td>s.sendall(string[, flag])</td><td>完整发送TCP数据，将字符串中的数据发送到链接的套接字，但在返回之前尝试发送所有数据。成功返回None，失败则抛出异常</td></tr><tr><td>s.recvfrom(bufsize[, flag])</td><td>接受UDP套接字的数据u，与recv()类似，但返回值是tuple(data, address)。其中data是包含接受数据的字符串，address是发送数据的套接字地址</td></tr><tr><td>s.sendto(string[, flag], address)</td><td>发送UDP数据，将数据发送到套接字，address形式为tuple(ipaddr, port)，指定远程地址发送，返回值是发送的字节数</td></tr><tr><td>s.close()</td><td>关闭套接字</td></tr><tr><td>s.getpeername()</td><td>返回套接字的远程地址，返回值通常是一个tuple(ipaddr, port)</td></tr><tr><td>s.getsockname()</td><td>返回套接字自己的地址，返回值通常是一个tuple(ipaddr, port)</td></tr><tr><td>s.setsockopt(level, optname, value)</td><td>设置给定套接字选项的值</td></tr><tr><td>s.getsockopt(level, optname[, buflen])</td><td>返回套接字选项的值</td></tr><tr><td>s.settimeout(timeout)</td><td>设置套接字操作的超时时间，timeout是一个浮点数，单位是秒，值为None则表示永远不会超时。一般超时期应在刚创建套接字时设置，因为他们可能用于连接的操作，如s.connect()</td></tr><tr><td>s.gettimeout()</td><td>返回当前超时值，单位是秒，如果没有设置超时则返回None</td></tr><tr><td>s.fileno()</td><td>返回套接字的文件描述</td></tr><tr><td>s.setblocking(flag)</td><td>如果flag为0，则将套接字设置为非阻塞模式，否则将套接字设置为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</td></tr><tr><td>s.makefile()</td><td>创建一个与该套接字相关的文件</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scoket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vsftpd基于pam_mysql的虚拟用户认证</title>
      <link href="/2017/03/23/ftp/"/>
      <url>/2017/03/23/ftp/</url>
      
        <content type="html"><![CDATA[<p>虚拟用户验证登录是ftp中常用的一种策略,因为ftp服务古老而且不安全,使用匿名用户不能有效的控制权限,而本地用户可以登录操作系统,极为不安全,所以引入了虚拟用户的概念,<code>其原理是将多个虚拟用户映射为一个本地用户</code>,从而加强了系统的安全性,本文主要介绍基于mysql的虚拟用户。 其原理图如下：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjdoo8wgj316z0kmgpz.jpg" alt="enter description here"><br><a id="more"></a><br>测试环境:<br>ftp服务器A : CenOS 6.9  IP:192.168.159.11<br>mysql服务器B : CenOS 6.9  IP:192.168.159.12</p><h2 id="一、安装所需要程序"><a href="#一、安装所需要程序" class="headerlink" title="一、安装所需要程序"></a>一、安装所需要程序</h2><hr><h3 id="1、安装ftp服务"><a href="#1、安装ftp服务" class="headerlink" title="1、安装ftp服务"></a>1、安装ftp服务</h3><blockquote><p>yum -y install ftp   #客户端<br>yum -y install vsftpd  #服务器</p></blockquote><h3 id="2、安装mysql服务"><a href="#2、安装mysql服务" class="headerlink" title="2、安装mysql服务"></a>2、安装mysql服务</h3><blockquote><p>yum -y install  mysql-server mysql-devel </p></blockquote><p>安装pam_mysql模块（只需在A主机安装）</p><blockquote><p>rpm -ivh <a href="http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm" target="_blank" rel="noopener">http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm</a><br>yum install pam_mysql  </p></blockquote><p><strong>注意</strong>：pam_mysql由epel源提供  </p><blockquote><p>service vsftpd start </p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjdw84g0j30ci05h75s.jpg" alt="以==ftp匿名==用户验证ftp能是否连接"></p><h2 id="二、在B主机mysql数据库中创建虚拟用户账号"><a href="#二、在B主机mysql数据库中创建虚拟用户账号" class="headerlink" title="二、在B主机mysql数据库中创建虚拟用户账号"></a>二、在B主机mysql数据库中创建虚拟用户账号</h2><hr><h3 id="1-准备数据库及相关表"><a href="#1-准备数据库及相关表" class="headerlink" title="1.准备数据库及相关表"></a>1.准备数据库及相关表</h3><p>启动mysql服务</p><blockquote><p>#service mysqld start</p><p>#ss  -ntl  #mysqld服务已启用并监听在3306默认端口</p></blockquote><p>确保mysql服务已经正常启动。而后，按需要建立存储虚拟用户的数据库，这里将其创建为vsftpd数据库。</p><blockquote><p>mysql&gt; create database vsftpd;<br> mysql&gt; grant select on vsftpd.* to <a href="mailto:vsftpd@192.168.159.12" target="_blank" rel="noopener">vsftpd@192.168.159.12</a> identified by ‘8520’;<br> mysql&gt; flush privileges;</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gje2xnkzj30qs07c40r.jpg" alt="验证A是否能登陆B主机"></p><p>如果不能，数据库问题请<a href="#a">看这里</a><br>在数据库中加用户表：</p><blockquote><p>mysql&gt; use vsftpd;<br>mysql&gt; create table users (<br> id int AUTO_INCREMENTNOT NULL,<br>  name char(20) binary NOT NULL,<br>  password char(48) binary NOT NULL,<br> primary key(id)  );</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjea5nlkj30fj0a9tb2.jpg" alt="enter description here"></p><h3 id="2、添加测试的虚拟用户"><a href="#2、添加测试的虚拟用户" class="headerlink" title="2、添加测试的虚拟用户"></a>2、添加测试的虚拟用户</h3><blockquote><p>mysql&gt; insert into users(name,password)values(‘tom’,password(‘8520’));<br>mysql&gt; insert into users(name,password) values(‘maria’,password(‘8520’));</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjeiv0v2j30en04mwfv.jpg" alt="查询虚拟用户信息"></p><h2 id="三、配置vsftpd"><a href="#三、配置vsftpd" class="headerlink" title="三、配置vsftpd"></a>三、配置vsftpd</h2><h3 id="1-建立pam认证所需文件"><a href="#1-建立pam认证所需文件" class="headerlink" title="1.建立pam认证所需文件"></a>1.建立pam认证所需文件</h3><p>#vim  /etc/pam.d/vsftpd.mysql<br>添加如下两行：</p><blockquote><p>auth required pam_mysql.so user=vsftpd passwd=8520 host=192.168.159.12 db=vsftpd table=users usercolumn=name passwdcolumn=password crypt=2<br>account pam_mysql.so user=vsftpd passwd=8520 host=192.168.159.12 db=vsftpd table=users usercolumn=name passwdcolumn=password crypt=2</p></blockquote><p><strong>tips：</strong></p><blockquote><p>auth 检查用户名密码<br>acccount （审查）检查用户是否在有限期内</p></blockquote><p><strong>注意</strong>：由于mysql的安装方式不同，pam_mysql.so基于unix sock连接mysql服务器时可能会出问题，此时，建议授权一个可远程连接的mysql并访问vsftpd数据库的用户。</p><h3 id="2-修改vsftpd的配置文件，使其适应mysql认证"><a href="#2-修改vsftpd的配置文件，使其适应mysql认证" class="headerlink" title="2.修改vsftpd的配置文件，使其适应mysql认证"></a>2.修改vsftpd的配置文件，使其适应mysql认证</h3><p>建立虚拟用户映射的系统用户及对应的目录</p><blockquote><p>useradd -s /sbin/nologin -d /var/ftproot vuser  #创建一个只能ftp登陆的用户<br>chmod go+rx /var/ftproot   #在其家目录让其他用户能读能写</p></blockquote><p>请确保/etc/vsftpd/vsftpd.conf中已经启用了以下选项<br>anonymous_enable=YES<br>local_enable=YES<br>write_enable=YES<br>anon_upload_enable=NO<br>anon_mkdir_write_enable=NO<br>chroot_local_user=YES</p><p>而后添加以下选项<br>guest_enable=YES<br>guest_username=vuser</p><p>并确保pam_service_name选项的值如下所示<br>pam_service_name=vsftpd.mysql</p><p>tips:默认为pam_service_name=vsftp 修改后系统用户将无法登陆</p><h2 id="四、启动vsftpd服务"><a href="#四、启动vsftpd服务" class="headerlink" title="四、启动vsftpd服务"></a>四、启动vsftpd服务</h2><blockquote><p>service vsftpd start<br>chkconfig vsftpd on</p></blockquote><p>查看端口开启情况</p><blockquote><p>netstat -tnlp |grep 21</p></blockquote><p>使用虚拟用户登录,验正配置结果，以下为本机的命令方式测试，你也可以在其它Win 上用IE或者FTP客户端工具登录验证。</p><blockquote><p>ftp 192.168.159.11</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gjepj4kpj30dj05tt9d.jpg" alt="虚拟用户tom登陆成功"></p><h2 id="五、配置虚拟用户具有不同的访问权限"><a href="#五、配置虚拟用户具有不同的访问权限" class="headerlink" title="五、配置虚拟用户具有不同的访问权限"></a>五、配置虚拟用户具有不同的访问权限</h2><p>vsftpd可以在配置文件目录中为每个用户提供单独的配置文件以定义其ftp服务访问权限，每个虚拟用户的配置文件名同虚拟用户的用户名。配置文件目录可以是任意未使用目录，只需要在vsftpd.conf指定其路径及名称即可。</p><h3 id="1、配置vsftpd为虚拟用户使用配置文件目录"><a href="#1、配置vsftpd为虚拟用户使用配置文件目录" class="headerlink" title="1、配置vsftpd为虚拟用户使用配置文件目录"></a>1、配置vsftpd为虚拟用户使用配置文件目录</h3><blockquote><p>vim /etc/vsftpd/vsftpd.conf</p></blockquote><p>添加如下选项:<br>user_config_dir=/etc/vsftpd/vusers_config #指定虚拟用户配置目录</p><h3 id="2、创建所需要目录，并为虚拟用户提供配置文件"><a href="#2、创建所需要目录，并为虚拟用户提供配置文件" class="headerlink" title="2、创建所需要目录，并为虚拟用户提供配置文件"></a>2、创建所需要目录，并为虚拟用户提供配置文件</h3><blockquote><p>mkdir /etc/vsftpd/vusers_config/<br>cd /etc/vsftpd/vusers_config/<br>touch tom maria</p></blockquote><h3 id="3、配置虚拟用户的访问权限"><a href="#3、配置虚拟用户的访问权限" class="headerlink" title="3、配置虚拟用户的访问权限"></a>3、配置虚拟用户的访问权限</h3><p>虚拟用户对vsftpd服务的访问权限是通过匿名用户的相关指令进行的。比如，如果需要让tom用户具有上传文件的权限，可以修改/etc/vsftpd/vusers_config/tom文件，在里面添加如下选项即可。<br>anon_upload_enable={YES|NO}<br>anon_mkdir_write_enable={YES|NO}<br>anon_other_write_enable={YES|NO}</p><p><span id="a"></span></p><blockquote><p>现象0：<br>ftp: connect :连接被拒绝<br> 原因： 服务没启动<br> 解决： # chkconfig vsftpd on<br> 现象1：<br> 500 OOPS: cannot open user list file<br> 原因： 不存在文件“/etc/vsftpd.user_list”或文件中不存在该帐户<br> 解决: # echo username &gt;&gt; /etc/vsftpd.user_list<br> 现象2：<br> 530 Permission denied.<br> Login failed.<br> 原因： “/etc/vsftpd.user_list”文件中不存在当前登陆用户<br> 解决： # echo username &gt;&gt; /etc/vsftpd.user_list<br> 现象3：<br> 500 OOPS: cannot open chroot() user list file<br> Login failed.<br> 原因： 不存在文件“/etc/vsftpd.chroot_list”<br> 解决： # echo username &gt;&gt; /etc/vsftpd.chroot_list<br> 现象4：<br> 500 OOPS: missing value in config file<br> Connection closed by remote host.<br> 原因： “=”等号前值有问题，或只有一个空格<br> 解决： 修正相应的值即可，可能过 diff 来比较查找<br> 现象5：<br> 500 OOPS: bad bool value in config file<br> Connection closed by remote host.<br> 原因： “=”等号后值有问题<br> 解决: 将“=”等号后值确认修改<br> 现象6:<br> 500 OOPS: unrecognised variable in config file<br> Connection closed by remote host.<br> 原因： 参数前有空格<br> 解决： 将参数前空格删除<br> 现象7、<br> 确认存在“local_enable=YES”，但本地用户无法登陆<br> 原因： 验证参数被误删除<br> 解决： 添加“pam_service_name=vsftpd”</p></blockquote><blockquote><p>现象8、<br> 500 OOPS: chdir<br> 500 OOPS: child died<br> Connection closed by remote host.<br> 原因： 用户主目录没有权限或没有主目录<br> 解决： 正确设置用户主目录权限</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Linux Service </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ftp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Samba文件共享</title>
      <link href="/2017/02/23/samba/"/>
      <url>/2017/02/23/samba/</url>
      
        <content type="html"><![CDATA[<p>建立samba共享，共享目录为/data，要求：<br> 1)共享名为shared，工作组为WORKGROUP；<br> 2)添加组develop，添加用户gentoo,centos和ubuntu，其中gentoo和centos以develop为附加组，ubuntu不属于develop组；密码均为8520；<br> 3)添加samba用户gentoo,centos和ubuntu，密码均为“8520”；<br> 4)此samba共享shared仅允许develop组具有写权限，其他用户只能以只读方式访问；<br> 5)此samba共享服务仅允许来自于172.16.0.0/16网络的主机访问；<br><a id="more"></a></p><h2 id="1、实验环境准备"><a href="#1、实验环境准备" class="headerlink" title="1、实验环境准备"></a>1、实验环境准备</h2><blockquote><p>yum  -y install samba #安装服务器<br>yum  -y install smbclient #安装客户端</p></blockquote><h2 id="2、Samba用户配置"><a href="#2、Samba用户配置" class="headerlink" title="2、Samba用户配置"></a>2、Samba用户配置</h2><blockquote><p>groupadd develop<br>useradd -G develop gentoo<br>useradd -G develop centos<br>useradd  ubuntu</p></blockquote><p><strong>tips：</strong><br>useradd -G 控制添加用户到主组<br>useradd -g 控制添加用户到附加组</p><p>添加系统用户为Samba用户：smbpasswd</p><blockquote><p>smbpasswd -a ubuntu<br>smbpasswd -a gentoo<br> smbpasswd -a centos</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">smbpasswd常用选项</span><br><span class="line">    -a Sys_User: 添加系统用户为samba用户</span><br><span class="line">-d ：禁用</span><br><span class="line">-e: 启用</span><br><span class="line">-x: 删除</span><br></pre></td></tr></table></figure><p>查看<code>Samba</code>文件<code>==&gt;</code>找到<code>Samba</code>的启动方式</p><blockquote><p>rpm -ql samba</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk21r856j307w049mx4.jpg" alt="enter description here"></p><p>如图可知：Samba开机自动启动服务，手动启动服务</p><blockquote><p>service nmb start<br>service smb start </p></blockquote><p>尝试登陆Samba用户个人目录</p><blockquote><p>smbclient  //192.168.159.12/ubuntu -U ubuntu</p></blockquote><p><img src="hhttps://ws1.sinaimg.cn/large/006v3NJegy1g1gk28ta8wj30hp05imxh.jpg" alt="enter description here"></p><h2 id="3、编辑Samba配置文件-etc-samba-smb-conf"><a href="#3、编辑Samba配置文件-etc-samba-smb-conf" class="headerlink" title="3、编辑Samba配置文件 /etc/samba/smb.conf"></a>3、编辑Samba配置文件 <code>/etc/samba/smb.conf</code></h2><blockquote><p>cp /etc/samba/smb.conf{,.bak} #先备份配置文件<br>vim /etc/samba/smb.conf</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk2exmbyj308i02lq2s.jpg" alt="enter description here"></p><p>修改用户组为WORKGROUP （在windows主机也能看到）<br>只让192.168.159.1~224的用户的登陆 </p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk2nzmofj30hi03gdfu.jpg" alt="enter description here"></p><p><strong>配置文件格式</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[shared_name]</span><br><span class="line">path = /path/to/share_directory</span><br><span class="line">comment = Comment String</span><br><span class="line">guest ok = &#123;yes|no&#125;</span><br><span class="line">public = &#123;yes|no&#125;</span><br><span class="line">writable = &#123;yes|no&#125;</span><br><span class="line">read only = &#123;yes|no&#125;</span><br><span class="line">write list = +GROUP_NAME</span><br></pre></td></tr></table></figure><h2 id="4、创建用户共享目录"><a href="#4、创建用户共享目录" class="headerlink" title="4、创建用户共享目录"></a>4、创建用户共享目录</h2><blockquote><p>mkdir /data<br>chmod 744 /data<br>setfacl -m group:develop:rwx /data #给特定develop（centos ，gentoo）组授予awx权限<br>getfacl /data</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk2vaxttj30b604njrc.jpg" alt="enter description here"></p><h2 id="5、测试"><a href="#5、测试" class="headerlink" title="5、测试"></a>5、测试</h2><p>用三个用户登陆个人家目录：</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk332w1dj30g70h6401.jpg" alt="enter description here"></p><p>gentoo用户成功登陆共享文件夹</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk3cqvjfj30f003wwem.jpg" alt="enter description here"></p><p>ubuntu登陆共享文件夹被拒绝</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk3lniv9j30ex027aa0.jpg" alt="enter description here"><br>在Windows下以ubuntu登陆访问文件夹被拒绝</p><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk3s2bt1j30ex027aa0.jpg" alt="enter description here"></p><p>ubuntu用户可以查看共享文件</p><blockquote><p>smbclient  -L //192.168.159.12 -U ubuntu  </p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006v3NJegy1g1gk3ynz5gj30g108jweu.jpg" alt="enter description here"></p>]]></content>
      
      
      <categories>
          
          <category> Linux Service </category>
          
      </categories>
      
      
        <tags>
            
            <tag> samba </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
